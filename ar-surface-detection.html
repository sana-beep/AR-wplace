<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AR Surface Detection & Object Placement</title>
    
    <!-- A-Frame and AR.js libraries -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    
         <style>
         /* Fullscreen mobile-friendly styling with retro aesthetic */
         body {
             margin: 0;
             overflow: hidden;
             font-family: 'Courier New', monospace;
             background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
             color: #00ff41;
             touch-action: none; /* Prevent default touch behaviors */
         }
         
         /* Retro scanlines effect */
         body::before {
             content: '';
             position: fixed;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             background: repeating-linear-gradient(
                 0deg,
                 transparent,
                 transparent 2px,
                 rgba(0, 255, 65, 0.03) 2px,
                 rgba(0, 255, 65, 0.03) 4px
             );
             pointer-events: none;
             z-index: 1;
         }
        
                 /* AR Session Status Panel */
         #status-panel {
             position: fixed;
             top: env(safe-area-inset-top, 20px);
             left: 50%;
             transform: translateX(-50%);
             background: rgba(0, 0, 0, 0.9);
             padding: 15px 25px;
             border-radius: 8px;
             z-index: 1000;
             text-align: center;
             border: 2px solid #00ff41;
             box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
             font-family: 'Courier New', monospace;
             min-width: 280px;
         }
        
        #status-text {
            font-size: 16px;
            font-weight: bold;
            margin: 0;
        }
        
                 /* Instructions Panel */
         #instructions {
             position: fixed;
             bottom: env(safe-area-inset-bottom, 20px);
             left: 50%;
             transform: translateX(-50%);
             background: rgba(0, 0, 0, 0.9);
             padding: 15px;
             border-radius: 8px;
             z-index: 1000;
             text-align: center;
             border: 2px solid #00ff41;
             box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
             max-width: 300px;
             transition: all 0.3s ease;
         }
         
         #instructions.minimized {
             transform: translateX(-50%) translateY(calc(100% - 40px));
             background: rgba(0, 0, 0, 0.7);
         }
         
         .instructions-header {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 10px;
             padding-bottom: 8px;
             border-bottom: 1px solid #00ff41;
         }
         
         .instructions-title {
             font-weight: bold;
             color: #00ff41;
             font-size: 14px;
         }
         
         .minimize-btn {
             background: none;
             border: 1px solid #00ff41;
             color: #00ff41;
             padding: 4px 8px;
             border-radius: 4px;
             cursor: pointer;
             font-family: 'Courier New', monospace;
             font-size: 12px;
             transition: all 0.2s ease;
         }
         
         .minimize-btn:hover {
             background: #00ff41;
             color: #000;
         }
        
        .instruction-text {
            font-size: 12px;
            margin: 5px 0;
            opacity: 0.9;
        }
        
                 /* Surface Detection Visual Feedback */
         .surface-marker {
             position: absolute;
             width: 20px;
             height: 20px;
             background: #00ff41;
             border-radius: 50%;
             border: 2px solid #ffffff;
             pointer-events: none;
             z-index: 999;
             animation: pulse 2s infinite;
             box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
         }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Object Selection Highlight */
        .selected-object {
            outline: 3px solid #FFD700;
            outline-offset: 2px;
        }
        
                 /* Debug Info (hidden by default) */
         #debug-info {
             position: fixed;
             top: env(safe-area-inset-top, 80px);
             right: 20px;
             background: rgba(0, 0, 0, 0.9);
             padding: 15px;
             border-radius: 8px;
             font-size: 11px;
             z-index: 1000;
             display: none;
             border: 2px solid #00ff41;
             box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
             font-family: 'Courier New', monospace;
             min-width: 200px;
         }
        
        /* Control Buttons */
        #controls {
            position: fixed;
            top: env(safe-area-inset-top, 20px);
            right: 20px;
            z-index: 1000;
        }
        
                 .control-btn {
             background: linear-gradient(135deg, #00ff41, #00cc33);
             color: #000;
             border: 2px solid #00ff41;
             padding: 8px 12px;
             border-radius: 6px;
             font-size: 12px;
             margin: 2px;
             cursor: pointer;
             font-family: 'Courier New', monospace;
             font-weight: bold;
             transition: all 0.2s ease;
             text-transform: uppercase;
             letter-spacing: 0.5px;
         }
         
         .control-btn:hover {
             background: linear-gradient(135deg, #00cc33, #00ff41);
             transform: translateY(-2px);
             box-shadow: 0 4px 15px rgba(0, 255, 65, 0.4);
         }
         
         .control-btn:active {
             transform: translateY(0) scale(0.98);
         }
         
         /* Menu Styling */
         #controls {
             position: fixed;
             top: env(safe-area-inset-top, 80px);
             right: 20px;
             z-index: 1000;
             background: rgba(0, 0, 0, 0.95);
             padding: 20px;
             border-radius: 8px;
             border: 2px solid #00ff41;
             box-shadow: 0 0 30px rgba(0, 255, 65, 0.3);
             max-width: 300px;
             max-height: 75vh;
             overflow-y: auto;
             font-family: 'Courier New', monospace;
         }
         
         .menu-section {
             margin-bottom: 20px;
             padding-bottom: 15px;
             border-bottom: 1px solid #333;
         }
         
         .menu-section:last-child {
             border-bottom: none;
             margin-bottom: 0;
         }
         
         .menu-section h3 {
             margin: 0 0 10px 0;
             font-size: 14px;
             color: #00ff41;
             text-align: center;
             text-transform: uppercase;
             letter-spacing: 1px;
             border-bottom: 1px solid #00ff41;
             padding-bottom: 5px;
         }
         
         #menu-toggle {
             font-size: 14px;
             padding: 10px 15px;
             border-radius: 8px;
             box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
             background: linear-gradient(135deg, #ff6b6b, #ee5a52);
             border: 2px solid #ff6b6b;
             font-family: 'Courier New', monospace;
             font-weight: bold;
             transition: all 0.3s ease;
         }
         
         #menu-toggle:hover {
             transform: scale(1.05);
             box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
         }
         
         /* Gesture Control Styling */
         .gesture-mode-buttons {
             display: flex;
             gap: 5px;
             margin-bottom: 10px;
         }
         
         .gesture-mode-btn {
             flex: 1;
             background: linear-gradient(135deg, #333, #444);
             color: #00ff41;
             border: 2px solid #00ff41;
             padding: 8px 6px;
             border-radius: 6px;
             font-size: 11px;
             cursor: pointer;
             transition: all 0.2s ease;
             font-family: 'Courier New', monospace;
             font-weight: bold;
             text-transform: uppercase;
             letter-spacing: 0.5px;
         }
         
         .gesture-mode-btn:hover {
             background: linear-gradient(135deg, #444, #555);
             border-color: #00ff41;
             transform: translateY(-1px);
             box-shadow: 0 2px 10px rgba(0, 255, 65, 0.3);
         }
         
         .gesture-mode-btn.active-mode {
             background: linear-gradient(135deg, #00ff41, #00cc33);
             border-color: #00ff41;
             color: #000;
             transform: scale(1.05);
             box-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
         }
         
         .gesture-instructions {
             text-align: center;
             padding: 12px;
             background: rgba(0, 255, 65, 0.1);
             border-radius: 6px;
             border: 1px solid rgba(0, 255, 65, 0.3);
             margin-top: 10px;
         }
         
         #gesture-mode-indicator {
             font-weight: bold;
             font-size: 14px;
             color: #00ff41;
             margin-bottom: 6px;
             text-transform: uppercase;
             letter-spacing: 1px;
         }
         
         .gesture-hint {
             font-size: 10px;
             opacity: 0.8;
         }
         
         /* Ensure proper spacing and prevent overlapping */
         .menu-section {
             margin-bottom: 25px;
             padding-bottom: 20px;
         }
         
         .menu-section:last-child {
             margin-bottom: 0;
             padding-bottom: 0;
         }
         
         /* Custom scrollbar for menu */
         #controls::-webkit-scrollbar {
             width: 8px;
         }
         
         #controls::-webkit-scrollbar-track {
             background: rgba(0, 255, 65, 0.1);
             border-radius: 4px;
         }
         
         #controls::-webkit-scrollbar-thumb {
             background: #00ff41;
             border-radius: 4px;
         }
         
         #controls::-webkit-scrollbar-thumb:hover {
             background: #00cc33;
         }
         
         /* Ensure all content is above scanlines */
         #status-panel, #instructions, #controls, #debug-info, #menu-toggle {
             z-index: 1000;
         }
    </style>
</head>
<body>
    <!-- Status Panel -->
    <div id="status-panel">
        <p id="status-text">🔍 Detecting surfaces...</p>
    </div>
    
         <!-- Instructions Panel -->
     <div id="instructions">
         <div class="instructions-header">
             <div class="instructions-title">📚 Instructions</div>
             <button class="minimize-btn" onclick="toggleInstructions()">−</button>
         </div>
         <div class="instruction-text">📱 Tap Menu button to open controls</div>
         <div class="instruction-text">🎲 Use Add Cube button to place objects</div>
         <div class="instruction-text">👆 Select gesture mode (Rotate/Scale/Move)</div>
         <div class="instruction-text">🖐️ Touch & drag to manipulate objects</div>
         <div class="instruction-text">🎯 Each mode has different touch behavior</div>
     </div>
    
         <!-- Menu Toggle Button -->
     <button id="menu-toggle" class="control-btn" onclick="toggleMenu()" style="position: fixed; top: env(safe-area-inset-top, 20px); right: 20px; z-index: 1001; background: #FF6B6B;">
         📱 Menu
     </button>
     
     <!-- Control Menu -->
     <div id="controls" style="display: none;">
         <div class="menu-section">
             <h3>🎯 Object Controls</h3>
             <button class="control-btn" onclick="addNewCube()">🎲 Add Cube</button>
             <button class="control-btn" onclick="clearAllObjects()">🗑️ Clear All</button>
         </div>
         
         <div class="menu-section">
             <h3>👆 Gesture Controls</h3>
             <div class="gesture-mode-buttons">
                 <button class="gesture-mode-btn active-mode" data-mode="rotate" onclick="setGestureMode('rotate')">🔄 Rotate</button>
                 <button class="gesture-mode-btn" data-mode="scale" onclick="setGestureMode('scale')">📏 Scale</button>
                 <button class="gesture-mode-btn" data-mode="move" onclick="setGestureMode('move')">🚀 Move</button>
             </div>
             <div class="gesture-instructions">
                 <div id="gesture-mode-indicator">🔄 ROTATE</div>
                 <div class="gesture-hint">Touch & drag to manipulate</div>
             </div>
         </div>
         
         <div class="menu-section">
             <h3>🔍 Surface Detection</h3>
             <button class="control-btn" onclick="enableSurfaceDetection()">✅ Enable Surface</button>
             <button class="control-btn" onclick="toggleSurfaceMarkers()">🟢 Toggle Dots</button>
         </div>
         
         <div class="menu-section">
             <h3>🧪 Testing</h3>
             <button class="control-btn" onclick="testObjectPlacement()">🧪 Test Object</button>
             <button class="control-btn" onclick="toggleDebug()">🐛 Debug Info</button>
         </div>
     </div>
    
    <!-- Debug Information -->
    <div id="debug-info">
        <div>Surface Count: <span id="surface-count">0</span></div>
        <div>Object Count: <span id="object-count">0</span></div>
        <div>Touch Points: <span id="touch-points">0</span></div>
    </div>
    
    <!-- AR Scene with Surface Detection -->
    <a-scene 
        embedded 
        arjs="sourceType: webcam; 
               facingMode: environment; 
               debugUIEnabled: false;
               detectionMode: mono_andmatrix;
               matrixCodeType: 3x3;
               sourceWidth: 1280;
               sourceHeight: 960;
               displayWidth: 1280;
               displayHeight: 960;">
        
        <!-- Surface Detection Marker -->
        <a-marker-camera 
            id="surface-marker" 
            preset="hiro" 
            visible="false"
            emitevents="true"
            cursor="rayOrigin: mouse">
            
            <!-- This will be our surface detection area -->
            <a-plane 
                id="surface-plane" 
                position="0 0 0" 
                rotation="-90 0 0" 
                width="10" 
                height="10" 
                color="rgba(0,255,0,0.3)" 
                visible="false">
            </a-plane>
        </a-marker-camera>
        
        <!-- AR Content Container -->
        <a-entity id="ar-content"></a-entity>
        
        <!-- Camera Entity -->
        <a-entity camera></a-entity>
        
        <!-- Lighting -->
        <a-light type="ambient" color="#ffffff" intensity="0.6"></a-light>
        <a-light type="directional" position="0 10 5" color="#ffffff" intensity="0.8"></a-light>
    </a-scene>
    
    <script>
        // ============================================================================
        // AR SESSION MANAGEMENT & SURFACE DETECTION
        // ============================================================================
        
        // Global variables for AR session management
        let arSession = null;
        let surfaceDetected = false;
        let placedObjects = [];
        let selectedObject = null;
        let isPlacingObject = false;
        
        // Surface detection variables
        let surfaceMarkers = [];
        let surfaceDetectionActive = false;
        
                 // Gesture control variables
         let touchStart = { x: 0, y: 0, time: 0 };
         let touchEnd = { x: 0, y: 0, time: 0 };
         let isDragging = false;
         let lastTouchDistance = 0;
         let lastTouchAngle = 0;
         let currentGestureMode = 'rotate'; // 'rotate', 'scale', 'move'
         let gestureActive = false;
        
        // ============================================================================
        // INITIALIZATION FUNCTIONS
        // ============================================================================
        
                 // Initialize AR session when page loads
         window.addEventListener('load', function() {
             console.log('🚀 AR Surface Detection App Loading...');
             initializeAR();
             initializeTouchGestures();
             updateStatus('🔍 Loading AR session...');
             
             // Add manual surface detection button functionality
             document.addEventListener('click', function(event) {
                 if (event.target.classList.contains('control-btn') && 
                     event.target.textContent.includes('Enable Surface')) {
                     enableSurfaceDetection();
                 }
             });
             
             // Initialize menu state
             document.getElementById('controls').style.display = 'none';
             
             // Initialize gesture mode display
             setTimeout(() => {
                 updateGestureModeDisplay();
             }, 100);
         });
        
        // Initialize AR session and surface detection
        function initializeAR() {
            console.log('📱 Initializing AR session...');
            
            // Get AR.js scene
            const scene = document.querySelector('a-scene');
            
            // Wait for AR.js to be ready
            scene.addEventListener('loaded', function() {
                console.log('✅ A-Frame scene loaded');
                checkCameraAccess();
            });
            
            // Wait for AR.js to be ready
            scene.addEventListener('arjs-nft-loaded', function() {
                console.log('✅ AR.js NFT system loaded');
            });
            
            // Listen for marker detection
            scene.addEventListener('markerFound', function(event) {
                console.log('🎯 Marker detected:', event.target);
                handleMarkerDetection(event);
            });
            
            // Listen for marker loss
            scene.addEventListener('markerLost', function(event) {
                console.log('❌ Marker lost:', event.target);
                handleMarkerLoss(event);
            });
            
            // Start surface detection after a short delay
            setTimeout(startSurfaceDetection, 2000);
        }
        
        // Check camera access
        function checkCameraAccess() {
            console.log('📷 Checking camera access...');
            
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
                    .then(function(stream) {
                        console.log('✅ Camera access granted');
                        updateStatus('📷 Camera ready - Enable surface detection to start');
                        
                        // Stop the stream since AR.js will handle it
                        stream.getTracks().forEach(track => track.stop());
                    })
                    .catch(function(error) {
                        console.error('❌ Camera access denied:', error);
                        updateStatus('❌ Camera access denied - Please allow camera access');
                    });
            } else {
                console.warn('⚠️ Camera API not supported');
                updateStatus('⚠️ Camera not supported on this device');
            }
        }
        
        // ============================================================================
        // SURFACE DETECTION SYSTEM
        // ============================================================================
        
        // Start surface detection using device sensors and camera analysis
        function startSurfaceDetection() {
            console.log('🔍 Starting surface detection...');
            surfaceDetectionActive = true;
            
            // Enable surface detection immediately for testing
            // In a real app, you'd use AR.js plane detection or device sensors
            setTimeout(() => {
                enableSurfaceDetection();
            }, 1000);
            
            // Request permissions for iOS
            if (window.DeviceMotionEvent && 'requestPermission' in DeviceMotionEvent) {
                DeviceMotionEvent.requestPermission().then(function(permissionState) {
                    if (permissionState === 'granted') {
                        console.log('✅ Motion permission granted');
                    }
                });
            }
            
            updateStatus('👆 Surface detection enabled - Tap anywhere to place objects');
        }
        
        // Enable surface detection (simplified approach)
        function enableSurfaceDetection() {
            if (!surfaceDetected) {
                surfaceDetected = true;
                console.log('✅ Surface detection enabled');
                updateStatus('✅ Ready! Tap anywhere to place objects');
                showSurfaceFeedback();
            }
        }
        
        // Simple surface detection using device stability
        function checkDeviceStability() {
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', function(event) {
                    if (!surfaceDetectionActive) return;
                    
                    const acceleration = event.accelerationIncludingGravity;
                    if (!acceleration) return;
                    
                    const x = acceleration.x || 0;
                    const y = acceleration.y || 0;
                    const z = acceleration.z || 0;
                    
                    // Calculate motion magnitude
                    const motionMagnitude = Math.sqrt(x*x + y*y + z*z);
                    
                    // If device is stable, enable surface detection
                    if (motionMagnitude < 1.0 && !surfaceDetected) {
                        enableSurfaceDetection();
                    }
                });
            }
        }
        
                 // Show visual feedback for detected surface
         function showSurfaceFeedback() {
             // Create visual surface markers
             createSurfaceMarkers();
             
             // Don't enable automatic tap-to-place anymore
             // Users must use the Add Cube button
             console.log('✅ Surface detection ready - Use Add Cube button to place objects');
         }
        
        // Hide surface feedback
        function hideSurfaceFeedback() {
            // Remove surface markers
            removeSurfaceMarkers();
            
            // Disable tap-to-place
            disableTapToPlace();
        }
        
        // Create visual surface markers
        function createSurfaceMarkers() {
            removeSurfaceMarkers();
            
            // Create a grid of surface markers
            for (let i = 0; i < 9; i++) {
                const marker = document.createElement('div');
                marker.className = 'surface-marker';
                marker.style.left = (20 + (i % 3) * 30) + '%';
                marker.style.top = (30 + Math.floor(i / 3) * 20) + '%';
                document.body.appendChild(marker);
                surfaceMarkers.push(marker);
            }
            
            updateDebugInfo();
        }
        
        // Remove surface markers
        function removeSurfaceMarkers() {
            surfaceMarkers.forEach(marker => marker.remove());
            surfaceMarkers = [];
            updateDebugInfo();
        }
        
        // ============================================================================
        // TAP-TO-PLACE SYSTEM
        // ============================================================================
        
        // Enable tap-to-place functionality (now only for object selection)
        function enableTapToPlace() {
            console.log('👆 Enabling object selection...');
            // Only enable object selection, not automatic placement
        }
        
        // Disable tap-to-place functionality
        function disableTapToPlace() {
            console.log('❌ Disabling object selection...');
        }
        
        // Handle tap-to-place events (now only for object selection)
        function handleTapToPlace(event) {
            try {
                // Only handle object selection, not automatic placement
                console.log('👆 Tap detected - checking for object selection...');
                
                // Check if tap is on a control button or menu
                if (event.target.closest('#controls') || event.target.closest('#menu-toggle')) {
                    return; // Don't process taps on UI elements
                }
                
                // Only select objects if surface detection is enabled
                if (surfaceDetected) {
                    // This will be handled by the existing object click handler
                    console.log('👆 Tap processed for object selection');
                }
                
            } catch (error) {
                console.error('❌ Error in handleTapToPlace:', error);
                updateStatus('❌ Error processing tap - Check console');
            }
        }
        
        // Convert screen coordinates to world coordinates
        function screenToWorldPosition(screenX, screenY) {
            try {
                // Validate input
                if (typeof screenX !== 'number' || typeof screenY !== 'number') {
                    console.warn('Invalid screen coordinates, using default positioning');
                    return { x: 0, y: 0, z: -3 };
                }
                
                // Get camera position and rotation
                const camera = document.querySelector('[camera]');
                if (!camera) {
                    console.warn('Camera not found, using default positioning');
                    return { x: 0, y: 0, z: -3 };
                }
                
                // Normalize screen coordinates (-1 to 1)
                const normalizedX = (screenX / window.innerWidth - 0.5) * 2;
                const normalizedY = (screenY / window.innerHeight - 0.5) * 2;
                
                // Calculate world position relative to camera
                const distance = 3; // Distance from camera
                const worldX = normalizedX * distance;
                const worldY = -normalizedY * distance; // Invert Y axis
                const worldZ = -distance; // Place in front of camera
                
                console.log('Screen coords:', screenX, screenY);
                console.log('World coords:', worldX, worldY, worldZ);
                
                return {
                    x: worldX,
                    y: worldY,
                    z: worldZ
                };
                
            } catch (error) {
                console.error('❌ Error in screenToWorldPosition:', error);
                return { x: 0, y: 0, z: -3 }; // Fallback position
            }
        }
        
        // Place a cube at the specified world position
        function placeCube(position) {
            try {
                console.log('🎲 Placing cube at:', position);
                
                // Validate position
                if (!position || typeof position.x === 'undefined') {
                    throw new Error('Invalid position object');
                }
                
                // Create cube entity
                const cube = document.createElement('a-box');
                cube.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
                cube.setAttribute('width', '1');
                cube.setAttribute('height', '1');
                cube.setAttribute('depth', '1');
                cube.setAttribute('color', getRandomColor());
                cube.setAttribute('material', 'shader: flat; roughness: 0.5; metalness: 0.1');
                
                // Add unique ID and make it selectable
                cube.setAttribute('id', `cube-${Date.now()}`);
                cube.setAttribute('class', 'placeable-object');
                cube.setAttribute('data-position', JSON.stringify(position));
                
                // Add to AR content container
                const arContent = document.getElementById('ar-content');
                if (!arContent) {
                    throw new Error('AR content container not found');
                }
                
                arContent.appendChild(cube);
                
                // Store reference
                placedObjects.push({
                    element: cube,
                    position: position,
                    rotation: { x: 0, y: 0, z: 0 },
                    scale: { x: 1, y: 1, z: 1 }
                });
                
                console.log('✅ Cube placed successfully');
                updateStatus(`🎲 Cube placed! Total objects: ${placedObjects.length}`);
                updateDebugInfo();
                
                // Select the newly placed object
                selectObject(cube);
                
            } catch (error) {
                console.error('❌ Error placing cube:', error);
                updateStatus(`❌ Failed to place cube: ${error.message}`);
            }
        }
        
        // ============================================================================
        // OBJECT SELECTION & GESTURE CONTROLS
        // ============================================================================
        
        // Select an object for manipulation
        function selectObject(object) {
            // Deselect previous object
            if (selectedObject) {
                selectedObject.classList.remove('selected-object');
            }
            
            // Select new object
            selectedObject = object;
            selectedObject.classList.add('selected-object');
            
            console.log('🎯 Object selected:', selectedObject.getAttribute('id'));
            updateStatus('🎯 Object selected - Use gestures to manipulate');
        }
        
                 // Initialize touch gesture controls
         function initializeTouchGestures() {
             console.log('👆 Initializing touch gestures...');
             
             // Add touch event listeners to the document
             document.addEventListener('touchstart', handleTouchStart, { passive: false });
             document.addEventListener('touchmove', handleTouchMove, { passive: false });
             document.addEventListener('touchend', handleTouchEnd, { passive: false });
             
             // Add click listener for object selection
             document.addEventListener('click', handleObjectClick);
             
             // Ensure gesture mode buttons work properly
             document.addEventListener('click', function(event) {
                 if (event.target.classList.contains('gesture-mode-btn')) {
                     const mode = event.target.getAttribute('data-mode');
                     if (mode) {
                         setGestureMode(mode);
                     }
                 }
             });
         }
        
                 // Handle touch start events - Simplified single-finger control
         function handleTouchStart(event) {
             if (!selectedObject) return;
             
             // Only handle single finger touches for object manipulation
             if (event.touches.length === 1) {
                 const touch = event.touches[0];
                 touchStart.x = touch.clientX;
                 touchStart.y = touch.clientY;
                 touchStart.time = Date.now();
                 isDragging = true;
                 gestureActive = true;
                 
                 console.log(`👆 Touch started in ${currentGestureMode} mode`);
                 
                 // Prevent default to avoid camera movement conflicts
                 event.preventDefault();
             }
         }
        
                 // Handle touch move events - Simplified single-finger control
         function handleTouchMove(event) {
             if (!isDragging || !selectedObject || !gestureActive) return;
             
             // Only handle single finger touches
             if (event.touches.length === 1) {
                 event.preventDefault();
                 
                 const touch = event.touches[0];
                 
                 // Handle based on current gesture mode
                 switch (currentGestureMode) {
                     case 'rotate':
                         handleRotation(touch);
                         break;
                     case 'scale':
                         handleScaling(touch);
                         break;
                     case 'move':
                         handleMovement(touch);
                         break;
                 }
             }
         }
        
                 // Handle touch end events
         function handleTouchEnd(event) {
             if (!isDragging) return;
             
             isDragging = false;
             gestureActive = false;
             
             console.log('👆 Touch gesture ended');
             
             // Update object data
             if (selectedObject) {
                 updateObjectData(selectedObject);
             }
         }
        
                 // Handle object rotation - Simplified and reliable
         function handleRotation(touch) {
             const deltaX = (touch.clientX - touchStart.x) * 0.8;
             const deltaY = (touch.clientY - touchStart.y) * 0.8;
             
             // Get current rotation
             const currentRotation = selectedObject.getAttribute('rotation');
             
             // Apply rotation changes (X and Y movement control different axes)
             const newRotation = {
                 x: currentRotation.x + deltaY,  // Vertical movement = X rotation
                 y: currentRotation.y + deltaX,  // Horizontal movement = Y rotation
                 z: currentRotation.z            // Keep Z rotation unchanged
             };
             
             // Apply rotation
             selectedObject.setAttribute('rotation', newRotation);
             
             // Update touch start for continuous rotation
             touchStart.x = touch.clientX;
             touchStart.y = touch.clientY;
             
             console.log(`🔄 Rotation: X=${newRotation.x.toFixed(1)}, Y=${newRotation.y.toFixed(1)}`);
         }
        
                 // Handle object scaling - Simplified single-finger control
         function handleScaling(touch) {
             // Use vertical movement for scaling (up = bigger, down = smaller)
             const deltaY = (touch.clientY - touchStart.y) * 0.01;
             
             // Get current scale
             const currentScale = selectedObject.getAttribute('scale');
             
             // Calculate new scale based on vertical movement
             const scaleChange = 1 + deltaY;
             const newScale = {
                 x: Math.max(0.1, Math.min(5, currentScale.x * scaleChange)),
                 y: Math.max(0.1, Math.min(5, currentScale.y * scaleChange)),
                 z: Math.max(0.1, Math.min(5, currentScale.z * scaleChange))
             };
             
             // Apply scaling
             selectedObject.setAttribute('scale', newScale);
             
             // Update touch start for continuous scaling
             touchStart.x = touch.clientX;
             touchStart.y = touch.clientY;
             
             console.log(`📏 Scale: X=${newScale.x.toFixed(2)}, Y=${newScale.y.toFixed(2)}, Z=${newScale.z.toFixed(2)}`);
         }
        
                 // Handle object movement - Simplified single-finger control
         function handleMovement(touch) {
             // Use horizontal and vertical movement for X and Y positioning
             const deltaX = (touch.clientX - touchStart.x) * 0.02;
             const deltaY = (touch.clientY - touchStart.y) * -0.02; // Invert Y for intuitive control
             
             // Get current position
             const currentPosition = selectedObject.getAttribute('position');
             
             // Apply movement
             const newPosition = {
                 x: currentPosition.x + deltaX,
                 y: currentPosition.y + deltaY,
                 z: currentPosition.z  // Keep Z position unchanged
             };
             
             // Clamp position to reasonable bounds
             newPosition.x = Math.max(-10, Math.min(10, newPosition.x));
             newPosition.y = Math.max(-5, Math.min(5, newPosition.y));
             newPosition.z = Math.max(-15, Math.min(-1, newPosition.z));
             
             // Apply position
             selectedObject.setAttribute('position', newPosition);
             
             // Update touch start for continuous movement
             touchStart.x = touch.clientX;
             touchStart.y = touch.clientY;
             
             console.log(`🚀 Position: X=${newPosition.x.toFixed(2)}, Y=${newPosition.y.toFixed(2)}, Z=${newPosition.z.toFixed(2)}`);
         }
        
        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        
        // Calculate distance between two touch points
        function getTouchDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Calculate angle between two touch points
        function getTouchAngle(touch1, touch2) {
            return Math.atan2(touch2.clientY - touch1.clientY, touch2.clientX - touch1.clientX);
        }
        
        // Generate random color for cubes
        function getRandomColor() {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // Update status display
        function updateStatus(message) {
            const statusText = document.getElementById('status-text');
            statusText.textContent = message;
            console.log('📱 Status:', message);
        }
        
        // Update debug information
        function updateDebugInfo() {
            document.getElementById('surface-count').textContent = surfaceMarkers.length;
            document.getElementById('object-count').textContent = placedObjects.length;
        }
        
        // Handle object clicks for selection
        function handleObjectClick(event) {
            // Check if click is on a placeable object
            const clickedElement = event.target;
            if (clickedElement.classList.contains('placeable-object')) {
                selectObject(clickedElement);
            }
        }
        
        // Update object data in storage
        function updateObjectData(object) {
            const objectId = object.getAttribute('id');
            const storedObject = placedObjects.find(obj => obj.element === object);
            
            if (storedObject) {
                storedObject.position = object.getAttribute('position');
                storedObject.rotation = object.getAttribute('rotation');
                storedObject.scale = object.getAttribute('scale');
                console.log('💾 Object data updated:', storedObject);
            }
        }
        
        // ============================================================================
        // CONTROL FUNCTIONS
        // ============================================================================
        
        // Toggle debug information
        function toggleDebug() {
            const debugInfo = document.getElementById('debug-info');
            debugInfo.style.display = debugInfo.style.display === 'none' ? 'block' : 'none';
        }
        
        // Toggle surface markers visibility
        function toggleSurfaceMarkers() {
            const surfaceMarkers = document.querySelectorAll('.surface-marker');
            if (surfaceMarkers.length > 0) {
                // Check if markers are visible
                const firstMarker = surfaceMarkers[0];
                const isVisible = firstMarker.style.display !== 'none';
                
                if (isVisible) {
                    // Hide markers
                    surfaceMarkers.forEach(marker => {
                        marker.style.display = 'none';
                    });
                    updateStatus('🔴 Surface markers hidden');
                } else {
                    // Show markers
                    surfaceMarkers.forEach(marker => {
                        marker.style.display = 'block';
                    });
                    updateStatus('🟢 Surface markers visible');
                }
            } else {
                updateStatus('⚠️ No surface markers to toggle');
                // Create markers if they don't exist
                if (surfaceDetected) {
                    createSurfaceMarkers();
                }
            }
        }
        
                 // Toggle menu visibility
         function toggleMenu() {
             const controls = document.getElementById('controls');
             const isVisible = controls.style.display !== 'none';
             
             if (isVisible) {
                 controls.style.display = 'none';
                 updateStatus('📱 Menu hidden');
             } else {
                 controls.style.display = 'block';
                 updateStatus('📱 Menu visible');
             }
         }
         
         // Set gesture mode
         function setGestureMode(mode) {
             currentGestureMode = mode;
             gestureActive = false;
             isDragging = false;
             
             // Update visual feedback
             updateGestureModeDisplay();
             
             // Update status
             const modeNames = {
                 'rotate': '🔄 Rotation Mode',
                 'scale': '📏 Scale Mode', 
                 'move': '🚀 Move Mode'
             };
             updateStatus(`${modeNames[mode]} - Touch and drag to manipulate`);
             
             console.log(`🎯 Gesture mode changed to: ${mode}`);
         }
         
         // Update gesture mode display
         function updateGestureModeDisplay() {
             // Update mode indicator
             const modeIndicator = document.getElementById('gesture-mode-indicator');
             if (modeIndicator) {
                 const modeIcons = {
                     'rotate': '🔄',
                     'scale': '📏',
                     'move': '🚀'
                 };
                 modeIndicator.textContent = `${modeIcons[currentGestureMode]} ${currentGestureMode.toUpperCase()}`;
             }
             
             // Update button states
             document.querySelectorAll('.gesture-mode-btn').forEach(btn => {
                 btn.classList.remove('active-mode');
                 if (btn.getAttribute('data-mode') === currentGestureMode) {
                     btn.classList.add('active-mode');
                 }
             });
         }
         
         // Toggle instructions panel
         function toggleInstructions() {
             const instructions = document.getElementById('instructions');
             instructions.classList.toggle('minimized');
             
             const minimizeBtn = document.querySelector('.minimize-btn');
             if (instructions.classList.contains('minimized')) {
                 minimizeBtn.textContent = '+';
                 minimizeBtn.title = 'Expand instructions';
             } else {
                 minimizeBtn.textContent = '−';
                 minimizeBtn.title = 'Minimize instructions';
             }
         }
        
        // Clear all placed objects
        function clearAllObjects() {
            console.log('🗑️ Clearing all objects...');
            
            // Remove all objects from scene
            placedObjects.forEach(obj => {
                if (obj.element.parentNode) {
                    obj.element.parentNode.removeChild(obj.element);
                }
            });
            
            // Clear arrays and references
            placedObjects = [];
            selectedObject = null;
            
            // Remove selection highlighting
            document.querySelectorAll('.selected-object').forEach(el => {
                el.classList.remove('selected-object');
            });
            
            updateStatus('🗑️ All objects cleared');
            updateDebugInfo();
        }
        
        // Test object placement function
        function testObjectPlacement() {
            try {
                console.log('🧪 Testing object placement...');
                
                if (!surfaceDetected) {
                    updateStatus('❌ Surface detection not enabled - Enable it first');
                    return;
                }
                
                // Create a simple test cube directly in the scene
                const arContent = document.getElementById('ar-content');
                if (!arContent) {
                    updateStatus('❌ AR content container not found');
                    return;
                }
                
                // Create cube entity
                const cube = document.createElement('a-box');
                cube.setAttribute('position', '0 0 -3');
                cube.setAttribute('width', '1');
                cube.setAttribute('height', '1');
                cube.setAttribute('depth', '1');
                cube.setAttribute('color', '#FF0000');
                cube.setAttribute('material', 'shader: flat');
                cube.setAttribute('id', `test-cube-${Date.now()}`);
                cube.setAttribute('class', 'placeable-object');
                
                // Add to scene
                arContent.appendChild(cube);
                
                // Store reference
                placedObjects.push({
                    element: cube,
                    position: { x: 0, y: 0, z: -3 },
                    rotation: { x: 0, y: 0, z: 0 },
                    scale: { x: 1, y: 1, z: 1 }
                });
                
                console.log('✅ Test cube placed successfully');
                updateStatus('🧪 Test cube placed! Check AR view');
                updateDebugInfo();
                
                // Select the test cube
                selectObject(cube);
                
            } catch (error) {
                console.error('❌ Error in testObjectPlacement:', error);
                updateStatus(`❌ Failed to place test cube: ${error.message}`);
            }
        }
        
        // Add new cube at center of screen
        function addNewCube() {
            try {
                console.log('🎲 Adding new cube...');
                
                if (!surfaceDetected) {
                    updateStatus('❌ Surface detection not enabled - Enable it first');
                    return;
                }
                
                // Create cube entity
                const cube = document.createElement('a-box');
                cube.setAttribute('position', '0 0 -3');
                cube.setAttribute('width', '1');
                cube.setAttribute('height', '1');
                cube.setAttribute('depth', '1');
                cube.setAttribute('color', getRandomColor());
                cube.setAttribute('material', 'shader: flat; roughness: 0.5; metalness: 0.1');
                cube.setAttribute('id', `cube-${Date.now()}`);
                cube.setAttribute('class', 'placeable-object');
                
                // Add to AR content container
                const arContent = document.getElementById('ar-content');
                if (!arContent) {
                    throw new Error('AR content container not found');
                }
                
                arContent.appendChild(cube);
                
                // Store reference
                placedObjects.push({
                    element: cube,
                    position: { x: 0, y: 0, z: -3 },
                    rotation: { x: 0, y: 0, z: 0 },
                    scale: { x: 1, y: 1, z: 1 }
                });
                
                console.log('✅ New cube added successfully');
                updateStatus(`🎲 New cube added! Total objects: ${placedObjects.length}`);
                updateDebugInfo();
                
                // Select the newly placed object
                selectObject(cube);
                
            } catch (error) {
                console.error('❌ Error adding new cube:', error);
                updateStatus(`❌ Failed to add cube: ${error.message}`);
            }
        }
        
        // ============================================================================
        // MARKER DETECTION HANDLERS (for compatibility)
        // ============================================================================
        
        // Handle marker detection (for compatibility with AR.js)
        function handleMarkerDetection(event) {
            console.log('🎯 Marker detected:', event.target);
            // You can add marker-specific logic here if needed
        }
        
        // Handle marker loss (for compatibility with AR.js)
        function handleMarkerLoss(event) {
            console.log('❌ Marker lost:', event.target);
            // You can add marker-specific logic here if needed
        }
        
        // ============================================================================
        // ERROR HANDLING & FALLBACKS
        // ============================================================================
        
        // Handle AR.js errors
        window.addEventListener('arjs-nft-loaded-error', function(event) {
            console.error('❌ AR.js NFT loading error:', event);
            updateStatus('❌ AR system error - Please refresh page');
        });
        
        // Handle general errors
        window.addEventListener('error', function(event) {
            console.error('❌ General error:', event.error);
            console.error('Error details:', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                error: event.error
            });
            updateStatus('❌ System error - Check console for details');
        });
        
        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            console.error('❌ Unhandled promise rejection:', event.reason);
            updateStatus('❌ Promise error - Check console for details');
        });
        
        console.log('🚀 AR Surface Detection App Initialized Successfully!');
    </script>
</body>
</html>
