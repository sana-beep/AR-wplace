<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AR Surface Detection & Object Placement</title>
    
    <!-- A-Frame and AR.js libraries -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    
    <style>
        /* Fullscreen mobile-friendly styling */
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: white;
            touch-action: none; /* Prevent default touch behaviors */
        }
        
        /* AR Session Status Panel */
        #status-panel {
            position: fixed;
            top: env(safe-area-inset-top, 20px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 25px;
            z-index: 1000;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 2px solid #007AFF;
        }
        
        #status-text {
            font-size: 16px;
            font-weight: bold;
            margin: 0;
        }
        
        /* Instructions Panel */
        #instructions {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 20px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            z-index: 1000;
            text-align: center;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        .instruction-text {
            font-size: 12px;
            margin: 5px 0;
            opacity: 0.9;
        }
        
        /* Surface Detection Visual Feedback */
        .surface-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #00FF00;
            border-radius: 50%;
            border: 2px solid #FFFFFF;
            pointer-events: none;
            z-index: 999;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Object Selection Highlight */
        .selected-object {
            outline: 3px solid #FFD700;
            outline-offset: 2px;
        }
        
        /* Debug Info (hidden by default) */
        #debug-info {
            position: fixed;
            top: env(safe-area-inset-top, 80px);
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            font-size: 10px;
            z-index: 1000;
            display: none;
        }
        
        /* Control Buttons */
        #controls {
            position: fixed;
            top: env(safe-area-inset-top, 20px);
            right: 20px;
            z-index: 1000;
        }
        
        .control-btn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            margin: 2px;
            cursor: pointer;
        }
        
                 .control-btn:active {
             background: #0056CC;
             transform: scale(0.95);
         }
         
         /* Menu Styling */
         #controls {
             position: fixed;
             top: env(safe-area-inset-top, 80px);
             right: 20px;
             z-index: 1000;
             background: rgba(0, 0, 0, 0.9);
             padding: 20px;
             border-radius: 15px;
             backdrop-filter: blur(15px);
             border: 2px solid #007AFF;
             max-width: 280px;
             max-height: 80vh;
             overflow-y: auto;
         }
         
         .menu-section {
             margin-bottom: 20px;
             padding-bottom: 15px;
             border-bottom: 1px solid #333;
         }
         
         .menu-section:last-child {
             border-bottom: none;
             margin-bottom: 0;
         }
         
         .menu-section h3 {
             margin: 0 0 10px 0;
             font-size: 14px;
             color: #007AFF;
             text-align: center;
         }
         
         #menu-toggle {
             font-size: 14px;
             padding: 10px 15px;
             border-radius: 25px;
             box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
         }
         
         /* Joystick Controls */
         #joystick-controls {
             position: fixed;
             bottom: env(safe-area-inset-bottom, 20px);
             left: 20px;
             z-index: 1000;
             background: rgba(0, 0, 0, 0.9);
             padding: 15px;
             border-radius: 15px;
             backdrop-filter: blur(15px);
             border: 2px solid #007AFF;
             display: none;
             min-width: 200px;
         }
         
         .joystick-section {
             margin-bottom: 15px;
             text-align: center;
         }
         
         .joystick-section:last-child {
             margin-bottom: 0;
         }
         
         .joystick-section h4 {
             margin: 0 0 10px 0;
             font-size: 12px;
             color: #007AFF;
         }
         
         .joystick {
             width: 80px;
             height: 80px;
             background: rgba(255, 255, 255, 0.1);
             border: 2px solid #007AFF;
             border-radius: 50%;
             position: relative;
             margin: 0 auto;
             cursor: pointer;
             touch-action: none;
         }
         
         .joystick-knob {
             width: 20px;
             height: 20px;
             background: #007AFF;
             border-radius: 50%;
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             transition: all 0.1s ease;
         }
         
         .joystick.active .joystick-knob {
             background: #FF6B6B;
         }
         
         .scale-slider {
             width: 100%;
             height: 6px;
             background: rgba(255, 255, 255, 0.2);
             border-radius: 3px;
             outline: none;
             -webkit-appearance: none;
         }
         
         .scale-slider::-webkit-slider-thumb {
             -webkit-appearance: none;
             width: 20px;
             height: 20px;
             background: #007AFF;
             border-radius: 50%;
             cursor: pointer;
         }
         
         .scale-slider::-moz-range-thumb {
             width: 20px;
             height: 20px;
             background: #007AFF;
             border-radius: 50%;
             cursor: pointer;
             border: none;
         }
         
         .scale-value {
             font-size: 12px;
             color: #007AFF;
             margin-top: 5px;
         }
         
         /* Minimize buttons */
         .minimize-btn {
             background: #FF6B6B;
             color: white;
             border: none;
             padding: 4px 8px;
             border-radius: 12px;
             font-size: 10px;
             cursor: pointer;
             margin-left: 10px;
         }
         
         .minimize-btn:hover {
             background: #FF5252;
         }
         
         /* Minimized state */
         .minimized {
             transform: translateY(calc(100% - 40px));
             background: rgba(0, 0, 0, 0.7);
         }
         
         .minimized .minimize-btn {
             background: #4CAF50;
         }
    </style>
</head>
<body>
         <!-- Status Panel -->
     <div id="status-panel">
         <p id="status-text">üîç Detecting surfaces...</p>
         <button class="minimize-btn" onclick="toggleStatusPanel()">‚àí</button>
     </div>
    
         <!-- Instructions Panel -->
     <div id="instructions">
         <div class="instruction-text">üì± Tap Menu button to open controls</div>
         <div class="instruction-text">üé≤ Use Add Cube button to place objects</div>
         <div class="instruction-text">üéÆ Use joysticks for precise movement</div>
         <div class="instruction-text">üîÑ One finger: Rotate selected object</div>
         <div class="instruction-text">üìè Two finger: Scale selected object</div>
         <div class="instruction-text">üöÄ Two finger: Move selected object</div>
         <button class="minimize-btn" onclick="toggleInstructions()">‚àí</button>
     </div>
     
     <!-- Joystick Controls -->
     <div id="joystick-controls">
         <div class="joystick-section">
             <h4>üéÆ X/Y Movement</h4>
             <div class="joystick" id="xy-joystick">
                 <div class="joystick-knob" id="xy-knob"></div>
             </div>
         </div>
         
         <div class="joystick-section">
             <h4>üìè Z Depth</h4>
             <div class="joystick" id="z-joystick">
                 <div class="joystick-knob" id="z-knob"></div>
             </div>
         </div>
         
         <div class="joystick-section">
             <h4>üîç Scale</h4>
             <input type="range" class="scale-slider" id="scale-slider" min="0.1" max="3" step="0.1" value="1">
             <div class="scale-value" id="scale-value">1.0x</div>
         </div>
         
         <button class="minimize-btn" onclick="toggleJoysticks()">‚àí</button>
     </div>
    
         <!-- Menu Toggle Button -->
     <button id="menu-toggle" class="control-btn" onclick="toggleMenu()" style="position: fixed; top: env(safe-area-inset-top, 20px); right: 20px; z-index: 1001; background: #FF6B6B;">
         üì± Menu
     </button>
     
     <!-- Control Menu -->
     <div id="controls" style="display: none;">
         <div class="menu-section">
             <h3>üéØ Object Controls</h3>
             <button class="control-btn" onclick="addNewCube()">üé≤ Add Cube</button>
             <button class="control-btn" onclick="clearAllObjects()">üóëÔ∏è Clear All</button>
         </div>
         
         <div class="menu-section">
             <h3>üîç Surface Detection</h3>
             <button class="control-btn" onclick="enableSurfaceDetection()">‚úÖ Enable Surface</button>
             <button class="control-btn" onclick="toggleSurfaceMarkers()">üü¢ Toggle Dots</button>
         </div>
         
         <div class="menu-section">
             <h3>üß™ Testing</h3>
             <button class="control-btn" onclick="testObjectPlacement()">üß™ Test Object</button>
             <button class="control-btn" onclick="toggleDebug()">üêõ Debug Info</button>
         </div>
         
         <div class="menu-section">
             <h3>üéÆ Controls</h3>
             <button class="control-btn" onclick="toggleJoysticks()">üéÆ Toggle Joysticks</button>
         </div>
     </div>
    
    <!-- Debug Information -->
    <div id="debug-info">
        <div>Surface Count: <span id="surface-count">0</span></div>
        <div>Object Count: <span id="object-count">0</span></div>
        <div>Touch Points: <span id="touch-points">0</span></div>
    </div>
    
    <!-- AR Scene with Surface Detection -->
    <a-scene 
        embedded 
        arjs="sourceType: webcam; 
               facingMode: environment; 
               debugUIEnabled: false;
               detectionMode: mono_andmatrix;
               matrixCodeType: 3x3;
               sourceWidth: 1280;
               sourceHeight: 960;
               displayWidth: 1280;
               displayHeight: 960;">
        
        <!-- Surface Detection Marker -->
        <a-marker-camera 
            id="surface-marker" 
            preset="hiro" 
            visible="false"
            emitevents="true"
            cursor="rayOrigin: mouse">
            
            <!-- This will be our surface detection area -->
            <a-plane 
                id="surface-plane" 
                position="0 0 0" 
                rotation="-90 0 0" 
                width="10" 
                height="10" 
                color="rgba(0,255,0,0.3)" 
                visible="false">
            </a-plane>
        </a-marker-camera>
        
        <!-- AR Content Container -->
        <a-entity id="ar-content"></a-entity>
        
        <!-- Camera Entity -->
        <a-entity camera></a-entity>
        
        <!-- Lighting -->
        <a-light type="ambient" color="#ffffff" intensity="0.6"></a-light>
        <a-light type="directional" position="0 10 5" color="#ffffff" intensity="0.8"></a-light>
    </a-scene>
    
    <script>
        // ============================================================================
        // AR SESSION MANAGEMENT & SURFACE DETECTION
        // ============================================================================
        
        // Global variables for AR session management
        let arSession = null;
        let surfaceDetected = false;
        let placedObjects = [];
        let selectedObject = null;
        let isPlacingObject = false;
        
        // Surface detection variables
        let surfaceMarkers = [];
        let surfaceDetectionActive = false;
        
        // Gesture control variables
        let touchStart = { x: 0, y: 0, time: 0 };
        let touchEnd = { x: 0, y: 0, time: 0 };
        let isDragging = false;
        let lastTouchDistance = 0;
        let lastTouchAngle = 0;
        let gestureMode = 'none'; // 'rotate', 'scale', 'move'
        
        // ============================================================================
        // INITIALIZATION FUNCTIONS
        // ============================================================================
        
                 // Initialize AR session when page loads
         window.addEventListener('load', function() {
             console.log('üöÄ AR Surface Detection App Loading...');
             initializeAR();
             initializeTouchGestures();
             initializeJoysticks();
             updateStatus('üîç Loading AR session...');
             
             // Add manual surface detection button functionality
             document.addEventListener('click', function(event) {
                 if (event.target.classList.contains('control-btn') && 
                     event.target.textContent.includes('Enable Surface')) {
                     enableSurfaceDetection();
                 }
             });
             
             // Initialize menu state
             document.getElementById('controls').style.display = 'none';
         });
        
        // Initialize AR session and surface detection
        function initializeAR() {
            console.log('üì± Initializing AR session...');
            
            // Get AR.js scene
            const scene = document.querySelector('a-scene');
            
            // Wait for AR.js to be ready
            scene.addEventListener('loaded', function() {
                console.log('‚úÖ A-Frame scene loaded');
                checkCameraAccess();
            });
            
            // Wait for AR.js to be ready
            scene.addEventListener('arjs-nft-loaded', function() {
                console.log('‚úÖ AR.js NFT system loaded');
            });
            
            // Listen for marker detection
            scene.addEventListener('markerFound', function(event) {
                console.log('üéØ Marker detected:', event.target);
                handleMarkerDetection(event);
            });
            
            // Listen for marker loss
            scene.addEventListener('markerLost', function(event) {
                console.log('‚ùå Marker lost:', event.target);
                handleMarkerLoss(event);
            });
            
            // Start surface detection after a short delay
            setTimeout(startSurfaceDetection, 2000);
        }
        
        // Check camera access
        function checkCameraAccess() {
            console.log('üì∑ Checking camera access...');
            
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
                    .then(function(stream) {
                        console.log('‚úÖ Camera access granted');
                        updateStatus('üì∑ Camera ready - Enable surface detection to start');
                        
                        // Stop the stream since AR.js will handle it
                        stream.getTracks().forEach(track => track.stop());
                    })
                    .catch(function(error) {
                        console.error('‚ùå Camera access denied:', error);
                        updateStatus('‚ùå Camera access denied - Please allow camera access');
                    });
            } else {
                console.warn('‚ö†Ô∏è Camera API not supported');
                updateStatus('‚ö†Ô∏è Camera not supported on this device');
            }
        }
        
        // ============================================================================
        // SURFACE DETECTION SYSTEM
        // ============================================================================
        
        // Start surface detection using device sensors and camera analysis
        function startSurfaceDetection() {
            console.log('üîç Starting surface detection...');
            surfaceDetectionActive = true;
            
            // Enable surface detection immediately for testing
            // In a real app, you'd use AR.js plane detection or device sensors
            setTimeout(() => {
                enableSurfaceDetection();
            }, 1000);
            
            // Request permissions for iOS
            if (window.DeviceMotionEvent && 'requestPermission' in DeviceMotionEvent) {
                DeviceMotionEvent.requestPermission().then(function(permissionState) {
                    if (permissionState === 'granted') {
                        console.log('‚úÖ Motion permission granted');
                    }
                });
            }
            
            updateStatus('üëÜ Surface detection enabled - Tap anywhere to place objects');
        }
        
        // Enable surface detection (simplified approach)
        function enableSurfaceDetection() {
            if (!surfaceDetected) {
                surfaceDetected = true;
                console.log('‚úÖ Surface detection enabled');
                updateStatus('‚úÖ Ready! Tap anywhere to place objects');
                showSurfaceFeedback();
            }
        }
        
        // Simple surface detection using device stability
        function checkDeviceStability() {
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', function(event) {
                    if (!surfaceDetectionActive) return;
                    
                    const acceleration = event.accelerationIncludingGravity;
                    if (!acceleration) return;
                    
                    const x = acceleration.x || 0;
                    const y = acceleration.y || 0;
                    const z = acceleration.z || 0;
                    
                    // Calculate motion magnitude
                    const motionMagnitude = Math.sqrt(x*x + y*y + z*z);
                    
                    // If device is stable, enable surface detection
                    if (motionMagnitude < 1.0 && !surfaceDetected) {
                        enableSurfaceDetection();
                    }
                });
            }
        }
        
                 // Show visual feedback for detected surface
         function showSurfaceFeedback() {
             // Create visual surface markers
             createSurfaceMarkers();
             
             // Don't enable automatic tap-to-place anymore
             // Users must use the Add Cube button
             console.log('‚úÖ Surface detection ready - Use Add Cube button to place objects');
         }
        
        // Hide surface feedback
        function hideSurfaceFeedback() {
            // Remove surface markers
            removeSurfaceMarkers();
            
            // Disable tap-to-place
            disableTapToPlace();
        }
        
        // Create visual surface markers
        function createSurfaceMarkers() {
            removeSurfaceMarkers();
            
            // Create a grid of surface markers
            for (let i = 0; i < 9; i++) {
                const marker = document.createElement('div');
                marker.className = 'surface-marker';
                marker.style.left = (20 + (i % 3) * 30) + '%';
                marker.style.top = (30 + Math.floor(i / 3) * 20) + '%';
                document.body.appendChild(marker);
                surfaceMarkers.push(marker);
            }
            
            updateDebugInfo();
        }
        
        // Remove surface markers
        function removeSurfaceMarkers() {
            surfaceMarkers.forEach(marker => marker.remove());
            surfaceMarkers = [];
            updateDebugInfo();
        }
        
        // ============================================================================
        // TAP-TO-PLACE SYSTEM
        // ============================================================================
        
        // Enable tap-to-place functionality (now only for object selection)
        function enableTapToPlace() {
            console.log('üëÜ Enabling object selection...');
            // Only enable object selection, not automatic placement
        }
        
        // Disable tap-to-place functionality
        function disableTapToPlace() {
            console.log('‚ùå Disabling object selection...');
        }
        
        // Handle tap-to-place events (now only for object selection)
        function handleTapToPlace(event) {
            try {
                // Only handle object selection, not automatic placement
                console.log('üëÜ Tap detected - checking for object selection...');
                
                // Check if tap is on a control button or menu
                if (event.target.closest('#controls') || event.target.closest('#menu-toggle')) {
                    return; // Don't process taps on UI elements
                }
                
                // Only select objects if surface detection is enabled
                if (surfaceDetected) {
                    // This will be handled by the existing object click handler
                    console.log('üëÜ Tap processed for object selection');
                }
                
            } catch (error) {
                console.error('‚ùå Error in handleTapToPlace:', error);
                updateStatus('‚ùå Error processing tap - Check console');
            }
        }
        
        // Convert screen coordinates to world coordinates
        function screenToWorldPosition(screenX, screenY) {
            try {
                // Validate input
                if (typeof screenX !== 'number' || typeof screenY !== 'number') {
                    console.warn('Invalid screen coordinates, using default positioning');
                    return { x: 0, y: 0, z: -3 };
                }
                
                // Get camera position and rotation
                const camera = document.querySelector('[camera]');
                if (!camera) {
                    console.warn('Camera not found, using default positioning');
                    return { x: 0, y: 0, z: -3 };
                }
                
                // Normalize screen coordinates (-1 to 1)
                const normalizedX = (screenX / window.innerWidth - 0.5) * 2;
                const normalizedY = (screenY / window.innerHeight - 0.5) * 2;
                
                // Calculate world position relative to camera
                const distance = 3; // Distance from camera
                const worldX = normalizedX * distance;
                const worldY = -normalizedY * distance; // Invert Y axis
                const worldZ = -distance; // Place in front of camera
                
                console.log('Screen coords:', screenX, screenY);
                console.log('World coords:', worldX, worldY, worldZ);
                
                return {
                    x: worldX,
                    y: worldY,
                    z: worldZ
                };
                
            } catch (error) {
                console.error('‚ùå Error in screenToWorldPosition:', error);
                return { x: 0, y: 0, z: -3 }; // Fallback position
            }
        }
        
        // Place a cube at the specified world position
        function placeCube(position) {
            try {
                console.log('üé≤ Placing cube at:', position);
                
                // Validate position
                if (!position || typeof position.x === 'undefined') {
                    throw new Error('Invalid position object');
                }
                
                // Create cube entity
                const cube = document.createElement('a-box');
                cube.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
                cube.setAttribute('width', '1');
                cube.setAttribute('height', '1');
                cube.setAttribute('depth', '1');
                cube.setAttribute('color', getRandomColor());
                cube.setAttribute('material', 'shader: flat; roughness: 0.5; metalness: 0.1');
                
                // Add unique ID and make it selectable
                cube.setAttribute('id', `cube-${Date.now()}`);
                cube.setAttribute('class', 'placeable-object');
                cube.setAttribute('data-position', JSON.stringify(position));
                
                // Add to AR content container
                const arContent = document.getElementById('ar-content');
                if (!arContent) {
                    throw new Error('AR content container not found');
                }
                
                arContent.appendChild(cube);
                
                // Store reference
                placedObjects.push({
                    element: cube,
                    position: position,
                    rotation: { x: 0, y: 0, z: 0 },
                    scale: { x: 1, y: 1, z: 1 }
                });
                
                console.log('‚úÖ Cube placed successfully');
                updateStatus(`üé≤ Cube placed! Total objects: ${placedObjects.length}`);
                updateDebugInfo();
                
                // Select the newly placed object
                selectObject(cube);
                
            } catch (error) {
                console.error('‚ùå Error placing cube:', error);
                updateStatus(`‚ùå Failed to place cube: ${error.message}`);
            }
        }
        
        // ============================================================================
        // OBJECT SELECTION & GESTURE CONTROLS
        // ============================================================================
        
        // Select an object for manipulation
        function selectObject(object) {
            // Deselect previous object
            if (selectedObject) {
                selectedObject.classList.remove('selected-object');
            }
            
            // Select new object
            selectedObject = object;
            selectedObject.classList.add('selected-object');
            
            console.log('üéØ Object selected:', selectedObject.getAttribute('id'));
            updateStatus('üéØ Object selected - Use gestures to manipulate');
        }
        
        // Initialize touch gesture controls
        function initializeTouchGestures() {
            console.log('üëÜ Initializing touch gestures...');
            
            // Add touch event listeners to the document
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Add click listener for object selection
            document.addEventListener('click', handleObjectClick);
        }
        
        // Handle touch start events
        function handleTouchStart(event) {
            if (!selectedObject) return;
            
            // Only prevent default for object manipulation, not camera movement
            if (event.touches.length === 1) {
                // Single finger - prepare for rotation
                touchStart.x = event.touches[0].clientX;
                touchStart.y = event.touches[0].clientY;
                touchStart.time = Date.now();
                isDragging = true;
                gestureMode = 'rotate';
                
                console.log('üîÑ Single finger touch - Rotation mode');
                
            } else if (event.touches.length === 2) {
                // Two fingers - prepare for scale or move
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                
                lastTouchDistance = getTouchDistance(touch1, touch2);
                lastTouchAngle = getTouchAngle(touch1, touch2);
                
                // Determine if this is a pinch (scale) or drag (move)
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                
                touchStart.x = centerX;
                touchStart.y = centerY;
                isDragging = true;
                
                // Check if fingers are moving apart/together (scale) vs moving together (move)
                setTimeout(() => {
                    if (isDragging) {
                        const currentDistance = getTouchDistance(touch1, touch2);
                        const distanceChange = Math.abs(currentDistance - lastTouchDistance);
                        
                        if (distanceChange > 10) {
                            gestureMode = 'scale';
                            console.log('üìè Two finger touch - Scale mode');
                        } else {
                            gestureMode = 'move';
                            console.log('üöÄ Two finger touch - Move mode');
                        }
                    }
                }, 100);
            }
        }
        
        // Handle touch move events
        function handleTouchMove(event) {
            if (!isDragging || !selectedObject) return;
            
            event.preventDefault();
            
            if (gestureMode === 'rotate' && event.touches.length === 1) {
                // Rotate object based on finger movement
                handleRotation(event.touches[0]);
                
            } else if (gestureMode === 'scale' && event.touches.length === 2) {
                // Scale object based on pinch gesture
                handleScaling(event.touches[0], event.touches[1]);
                
            } else if (gestureMode === 'move' && event.touches.length === 2) {
                // Move object based on two-finger drag
                handleMovement(event.touches[0], event.touches[1]);
            }
        }
        
        // Handle touch end events
        function handleTouchEnd(event) {
            if (!isDragging) return;
            
            isDragging = false;
            gestureMode = 'none';
            
            console.log('üëÜ Touch gesture ended');
            
            // Update object data
            if (selectedObject) {
                updateObjectData(selectedObject);
            }
        }
        
        // Handle object rotation
        function handleRotation(touch) {
            const deltaX = (touch.clientX - touchStart.x) * 0.5;
            const deltaY = (touch.clientY - touchStart.y) * 0.5;
            
            // Get current rotation
            const currentRotation = selectedObject.getAttribute('rotation');
            
            // Apply rotation changes
            const newRotation = {
                x: currentRotation.x + deltaY,
                y: currentRotation.y + deltaX,
                z: currentRotation.z
            };
            
            selectedObject.setAttribute('rotation', newRotation);
            
            // Update touch start for continuous rotation
            touchStart.x = touch.clientX;
            touchStart.y = touch.clientY;
        }
        
        // Handle object scaling
        function handleScaling(touch1, touch2) {
            const currentDistance = getTouchDistance(touch1, touch2);
            const scaleFactor = currentDistance / lastTouchDistance;
            
            // Get current scale
            const currentScale = selectedObject.getAttribute('scale');
            
            // Apply scaling (clamp to reasonable limits)
            const newScale = {
                x: Math.max(0.1, Math.min(5, currentScale.x * scaleFactor)),
                y: Math.max(0.1, Math.min(5, currentScale.y * scaleFactor)),
                z: Math.max(0.1, Math.min(5, currentScale.z * scaleFactor))
            };
            
            selectedObject.setAttribute('scale', newScale);
            
            // Update last distance for continuous scaling
            lastTouchDistance = currentDistance;
        }
        
        // Handle object movement
        function handleMovement(touch1, touch2) {
            const centerX = (touch1.clientX + touch2.clientX) / 2;
            const centerY = (touch1.clientY + touch2.clientY) / 2;
            
            const deltaX = (centerX - touchStart.x) * 0.01;
            const deltaY = (centerY - touchStart.y) * -0.01;
            
            // Get current position
            const currentPosition = selectedObject.getAttribute('position');
            
            // Apply movement
            const newPosition = {
                x: currentPosition.x + deltaX,
                y: currentPosition.y + deltaY,
                z: currentPosition.z
            };
            
            // Clamp position to reasonable bounds
            newPosition.x = Math.max(-10, Math.min(10, newPosition.x));
            newPosition.y = Math.max(-5, Math.min(5, newPosition.y));
            newPosition.z = Math.max(-15, Math.min(-1, newPosition.z));
            
            selectedObject.setAttribute('position', newPosition);
            
            // Update touch start for continuous movement
            touchStart.x = centerX;
            touchStart.y = centerY;
        }
        
        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        
        // Calculate distance between two touch points
        function getTouchDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Calculate angle between two touch points
        function getTouchAngle(touch1, touch2) {
            return Math.atan2(touch2.clientY - touch1.clientY, touch2.clientX - touch1.clientX);
        }
        
        // Generate random color for cubes
        function getRandomColor() {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // Update status display
        function updateStatus(message) {
            const statusText = document.getElementById('status-text');
            statusText.textContent = message;
            console.log('üì± Status:', message);
        }
        
        // Update debug information
        function updateDebugInfo() {
            document.getElementById('surface-count').textContent = surfaceMarkers.length;
            document.getElementById('object-count').textContent = placedObjects.length;
        }
        
        // Handle object clicks for selection
        function handleObjectClick(event) {
            // Check if click is on a placeable object
            const clickedElement = event.target;
            if (clickedElement.classList.contains('placeable-object')) {
                selectObject(clickedElement);
            }
        }
        
        // Update object data in storage
        function updateObjectData(object) {
            const objectId = object.getAttribute('id');
            const storedObject = placedObjects.find(obj => obj.element === object);
            
            if (storedObject) {
                storedObject.position = object.getAttribute('position');
                storedObject.rotation = object.getAttribute('rotation');
                storedObject.scale = object.getAttribute('scale');
                console.log('üíæ Object data updated:', storedObject);
            }
        }
        
        // ============================================================================
        // CONTROL FUNCTIONS
        // ============================================================================
        
        // Toggle debug information
        function toggleDebug() {
            const debugInfo = document.getElementById('debug-info');
            debugInfo.style.display = debugInfo.style.display === 'none' ? 'block' : 'none';
        }
        
        // Toggle surface markers visibility
        function toggleSurfaceMarkers() {
            const surfaceMarkers = document.querySelectorAll('.surface-marker');
            if (surfaceMarkers.length > 0) {
                // Check if markers are visible
                const firstMarker = surfaceMarkers[0];
                const isVisible = firstMarker.style.display !== 'none';
                
                if (isVisible) {
                    // Hide markers
                    surfaceMarkers.forEach(marker => {
                        marker.style.display = 'none';
                    });
                    updateStatus('üî¥ Surface markers hidden');
                } else {
                    // Show markers
                    surfaceMarkers.forEach(marker => {
                        marker.style.display = 'block';
                    });
                    updateStatus('üü¢ Surface markers visible');
                }
            } else {
                updateStatus('‚ö†Ô∏è No surface markers to toggle');
                // Create markers if they don't exist
                if (surfaceDetected) {
                    createSurfaceMarkers();
                }
            }
        }
        
                 // Toggle menu visibility
         function toggleMenu() {
             const controls = document.getElementById('controls');
             const isVisible = controls.style.display !== 'none';
             
             if (isVisible) {
                 controls.style.display = 'none';
                 updateStatus('üì± Menu hidden');
             } else {
                 controls.style.display = 'block';
                 updateStatus('üì± Menu visible');
             }
         }
         
         // Toggle joystick controls
         function toggleJoysticks() {
             const joysticks = document.getElementById('joystick-controls');
             const isVisible = joysticks.style.display !== 'none';
             
             if (isVisible) {
                 joysticks.style.display = 'none';
                 updateStatus('üéÆ Joysticks hidden');
             } else {
                 joysticks.style.display = 'block';
                 updateStatus('üéÆ Joysticks visible');
             }
         }
         
         // Toggle status panel
         function toggleStatusPanel() {
             const statusPanel = document.getElementById('status-panel');
             statusPanel.classList.toggle('minimized');
             
             const minimizeBtn = statusPanel.querySelector('.minimize-btn');
             if (statusPanel.classList.contains('minimized')) {
                 minimizeBtn.textContent = '+';
                 minimizeBtn.title = 'Expand status';
             } else {
                 minimizeBtn.textContent = '‚àí';
                 minimizeBtn.title = 'Minimize status';
             }
         }
         
         // Toggle instructions panel
         function toggleInstructions() {
             const instructions = document.getElementById('instructions');
             instructions.classList.toggle('minimized');
             
             const minimizeBtn = instructions.querySelector('.minimize-btn');
             if (instructions.classList.contains('minimized')) {
                 minimizeBtn.textContent = '+';
                 minimizeBtn.title = 'Expand instructions';
             } else {
                 minimizeBtn.textContent = '‚àí';
                 minimizeBtn.title = 'Minimize instructions';
             }
         }
         
         // Toggle joystick panel
         function toggleJoysticks() {
             const joysticks = document.getElementById('joystick-controls');
             joysticks.classList.toggle('minimized');
             
             const minimizeBtn = joysticks.querySelector('.minimize-btn');
             if (joysticks.classList.contains('minimized')) {
                 minimizeBtn.textContent = '+';
                 minimizeBtn.title = 'Expand joysticks';
             } else {
                 minimizeBtn.textContent = '‚àí';
                 minimizeBtn.title = 'Minimize joysticks';
             }
         }
         
         // Initialize joystick controls
         function initializeJoysticks() {
             console.log('üéÆ Initializing joystick controls...');
             
             // XY Joystick for X/Y movement
             const xyJoystick = document.getElementById('xy-joystick');
             const xyKnob = document.getElementById('xy-knob');
             
             // Z Joystick for depth
             const zJoystick = document.getElementById('z-joystick');
             const zKnob = document.getElementById('z-knob');
             
             // Scale slider
             const scaleSlider = document.getElementById('scale-slider');
             const scaleValue = document.getElementById('scale-value');
             
             // XY Joystick events
             let xyActive = false;
             
             xyJoystick.addEventListener('mousedown', startXYJoystick);
             xyJoystick.addEventListener('touchstart', startXYJoystick);
             document.addEventListener('mousemove', moveXYJoystick);
             document.addEventListener('touchmove', moveXYJoystick);
             document.addEventListener('mouseup', stopXYJoystick);
             document.addEventListener('touchend', stopXYJoystick);
             
             // Z Joystick events
             let zActive = false;
             
             zJoystick.addEventListener('mousedown', startZJoystick);
             zJoystick.addEventListener('touchstart', startZJoystick);
             document.addEventListener('mousemove', moveZJoystick);
             document.addEventListener('touchmove', moveZJoystick);
             document.addEventListener('mouseup', stopZJoystick);
             document.addEventListener('touchend', stopZJoystick);
             
             // Scale slider events
             scaleSlider.addEventListener('input', handleScaleChange);
             
             function startXYJoystick(event) {
                 xyActive = true;
                 xyJoystick.classList.add('active');
                 event.preventDefault();
             }
             
             function moveXYJoystick(event) {
                 if (!xyActive || !selectedObject) return;
                 
                 const rect = xyJoystick.getBoundingClientRect();
                 const centerX = rect.left + rect.width / 2;
                 const centerY = rect.top + rect.height / 2;
                 
                 let clientX, clientY;
                 if (event.touches) {
                     clientX = event.touches[0].clientX;
                     clientY = event.clientY;
                 } else {
                     clientX = event.clientX;
                     clientY = event.clientY;
                 }
                 
                 const deltaX = (clientX - centerX) / (rect.width / 2);
                 const deltaY = (clientY - centerY) / (rect.height / 2);
                 
                 // Clamp to joystick bounds
                 const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                 if (distance > 1) {
                     const clampedX = deltaX / distance;
                     const clampedY = deltaY / distance;
                     
                     // Update knob position
                     xyKnob.style.left = `${50 + clampedX * 30}%`;
                     xyKnob.style.top = `${50 + clampedY * 30}%`;
                     
                     // Move object
                     const currentPos = selectedObject.getAttribute('position');
                     const newPos = {
                         x: currentPos.x + clampedX * 0.05,
                         y: currentPos.y - clampedY * 0.05,
                         z: currentPos.z
                     };
                     
                     // Clamp position
                     newPos.x = Math.max(-10, Math.min(10, newPos.x));
                     newPos.y = Math.max(-5, Math.min(5, newPos.y));
                     
                     selectedObject.setAttribute('position', newPos);
                     updateObjectData(selectedObject);
                 }
             }
             
             function stopXYJoystick() {
                 xyActive = false;
                 xyJoystick.classList.remove('active');
                 
                 // Reset knob position
                 xyKnob.style.left = '50%';
                 xyKnob.style.top = '50%';
             }
             
             function startZJoystick(event) {
                 zActive = true;
                 zJoystick.classList.add('active');
                 event.preventDefault();
             }
             
             function moveZJoystick(event) {
                 if (!zActive || !selectedObject) {
                     return;
                 }
                 
                 const rect = zJoystick.getBoundingClientRect();
                 const centerY = rect.top + rect.height / 2;
                 
                 let clientY;
                 if (event.touches) {
                     clientY = event.touches[0].clientY;
                 } else {
                     clientY = event.clientY;
                 }
                 
                 const deltaY = (clientY - centerY) / (rect.height / 2);
                 
                 // Clamp to joystick bounds
                 const clampedY = Math.max(-1, Math.min(1, deltaY));
                 
                 // Update knob position
                 zKnob.style.top = `${50 + clampedY * 30}%`;
                 
                 // Move object in Z direction
                 const currentPos = selectedObject.getAttribute('position');
                 const newPos = {
                     x: currentPos.x,
                     y: currentPos.y,
                     z: currentPos.z + clampedY * 0.1
                 };
                 
                 // Clamp Z position
                 newPos.z = Math.max(-15, Math.min(-1, newPos.z));
                 
                 selectedObject.setAttribute('position', newPos);
                 updateObjectData(selectedObject);
             }
             
             function stopZJoystick() {
                 zActive = false;
                 zJoystick.classList.remove('active');
                 
                 // Reset knob position
                 zKnob.style.top = '50%';
             }
             
             function handleScaleChange(event) {
                 if (!selectedObject) return;
                 
                 const scale = parseFloat(event.target.value);
                 scaleValue.textContent = `${scale.toFixed(1)}x`;
                 
                 selectedObject.setAttribute('scale', { x: scale, y: scale, z: scale });
                 updateObjectData(selectedObject);
             }
             
             console.log('‚úÖ Joystick controls initialized');
         }
        
        // Clear all placed objects
        function clearAllObjects() {
            console.log('üóëÔ∏è Clearing all objects...');
            
            // Remove all objects from scene
            placedObjects.forEach(obj => {
                if (obj.element.parentNode) {
                    obj.element.parentNode.removeChild(obj.element);
                }
            });
            
            // Clear arrays and references
            placedObjects = [];
            selectedObject = null;
            
            // Remove selection highlighting
            document.querySelectorAll('.selected-object').forEach(el => {
                el.classList.remove('selected-object');
            });
            
            updateStatus('üóëÔ∏è All objects cleared');
            updateDebugInfo();
        }
        
        // Test object placement function
        function testObjectPlacement() {
            try {
                console.log('üß™ Testing object placement...');
                
                if (!surfaceDetected) {
                    updateStatus('‚ùå Surface detection not enabled - Enable it first');
                    return;
                }
                
                // Create a simple test cube directly in the scene
                const arContent = document.getElementById('ar-content');
                if (!arContent) {
                    updateStatus('‚ùå AR content container not found');
                    return;
                }
                
                // Create cube entity
                const cube = document.createElement('a-box');
                cube.setAttribute('position', '0 0 -3');
                cube.setAttribute('width', '1');
                cube.setAttribute('height', '1');
                cube.setAttribute('depth', '1');
                cube.setAttribute('color', '#FF0000');
                cube.setAttribute('material', 'shader: flat');
                cube.setAttribute('id', `test-cube-${Date.now()}`);
                cube.setAttribute('class', 'placeable-object');
                
                // Add to scene
                arContent.appendChild(cube);
                
                // Store reference
                placedObjects.push({
                    element: cube,
                    position: { x: 0, y: 0, z: -3 },
                    rotation: { x: 0, y: 0, z: 0 },
                    scale: { x: 1, y: 1, z: 1 }
                });
                
                console.log('‚úÖ Test cube placed successfully');
                updateStatus('üß™ Test cube placed! Check AR view');
                updateDebugInfo();
                
                // Select the test cube
                selectObject(cube);
                
            } catch (error) {
                console.error('‚ùå Error in testObjectPlacement:', error);
                updateStatus(`‚ùå Failed to place test cube: ${error.message}`);
            }
        }
        
        // Add new cube at center of screen
        function addNewCube() {
            try {
                console.log('üé≤ Adding new cube...');
                
                if (!surfaceDetected) {
                    updateStatus('‚ùå Surface detection not enabled - Enable it first');
                    return;
                }
                
                // Create cube entity
                const cube = document.createElement('a-box');
                cube.setAttribute('position', '0 0 -3');
                cube.setAttribute('width', '1');
                cube.setAttribute('height', '1');
                cube.setAttribute('depth', '1');
                cube.setAttribute('color', getRandomColor());
                cube.setAttribute('material', 'shader: flat; roughness: 0.5; metalness: 0.1');
                cube.setAttribute('id', `cube-${Date.now()}`);
                cube.setAttribute('class', 'placeable-object');
                
                // Add to AR content container
                const arContent = document.getElementById('ar-content');
                if (!arContent) {
                    throw new Error('AR content container not found');
                }
                
                arContent.appendChild(cube);
                
                // Store reference
                placedObjects.push({
                    element: cube,
                    position: { x: 0, y: 0, z: -3 },
                    rotation: { x: 0, y: 0, z: 0 },
                    scale: { x: 1, y: 1, z: 1 }
                });
                
                console.log('‚úÖ New cube added successfully');
                updateStatus(`üé≤ New cube added! Total objects: ${placedObjects.length}`);
                updateDebugInfo();
                
                // Select the newly placed object
                selectObject(cube);
                
            } catch (error) {
                console.error('‚ùå Error adding new cube:', error);
                updateStatus(`‚ùå Failed to add cube: ${error.message}`);
            }
        }
        
        // ============================================================================
        // MARKER DETECTION HANDLERS (for compatibility)
        // ============================================================================
        
        // Handle marker detection (for compatibility with AR.js)
        function handleMarkerDetection(event) {
            console.log('üéØ Marker detected:', event.target);
            // You can add marker-specific logic here if needed
        }
        
        // Handle marker loss (for compatibility with AR.js)
        function handleMarkerLoss(event) {
            console.log('‚ùå Marker lost:', event.target);
            // You can add marker-specific logic here if needed
        }
        
        // ============================================================================
        // ERROR HANDLING & FALLBACKS
        // ============================================================================
        
        // Handle AR.js errors
        window.addEventListener('arjs-nft-loaded-error', function(event) {
            console.error('‚ùå AR.js NFT loading error:', event);
            updateStatus('‚ùå AR system error - Please refresh page');
        });
        
        // Handle general errors
        window.addEventListener('error', function(event) {
            console.error('‚ùå General error:', event.error);
            console.error('Error details:', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                error: event.error
            });
            updateStatus('‚ùå System error - Check console for details');
        });
        
        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            console.error('‚ùå Unhandled promise rejection:', event.reason);
            updateStatus('‚ùå Promise error - Check console for details');
        });
        
        console.log('üöÄ AR Surface Detection App Initialized Successfully!');
    </script>
</body>
</html>
