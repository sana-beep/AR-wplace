<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Wplace AR - iOS (Multi-Sensor)</title>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ar.js@3.3.2/aframe/build/aframe-ar.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
      }
      #info-panel {
        position: fixed;
        top: env(safe-area-inset-top, 20px);
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px;
        border-radius: 15px;
        z-index: 1000;
        max-width: 350px;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        font-size: 12px;
        line-height: 1.3;
      }
      #location-info {
        margin-bottom: 10px;
      }
      #wplace-data {
        font-size: 12px;
        line-height: 1.4;
      }
      .sensor-data {
        margin: 5px 0;
        font-size: 11px;
        opacity: 0.9;
      }
      .loading {
        color: #ffd700;
      }
      .error {
        color: #ff6b6b;
      }
      .success {
        color: #34C759;
      }
      .ios-button {
        background: #007AFF;
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 25px;
        font-size: 16px;
        font-weight: 600;
        margin: 10px 5px;
        cursor: pointer;
        -webkit-appearance: none;
      }
      .ios-button:active {
        background: #0056CC;
        transform: scale(0.95);
      }
      #camera-controls {
        position: fixed;
        bottom: env(safe-area-inset-bottom, 20px);
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        text-align: center;
      }
      #camera-status {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 15px;
        z-index: 2000;
        text-align: center;
        display: none;
      }
      .sensor-indicator {
        position: fixed;
        top: env(safe-area-inset-top, 20px);
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 10px;
        z-index: 1000;
        font-size: 11px;
        text-align: center;
      }
      .sensor-dot {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin: 0 2px;
      }
             .sensor-active { background: #34C759; }
       .sensor-inactive { background: #FF3B30; }
       .sensor-unknown { background: #FF9500; }
              .sensor-triggered { background: #FFD700; animation: pulse 1s infinite; }
       
       @keyframes pulse {
         0% { transform: scale(1); }
         50% { transform: scale(1.2); }
         100% { transform: scale(1); }
       }
       
       #camera-feed {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        object-fit: cover;
        display: none;
      }
    </style>
  </head>
  <body>
    <!-- Hidden camera feed for debugging -->
    <video id="camera-feed" autoplay playsinline muted></video>

    <div id="info-panel">
      <div id="location-info">
        <strong>üìç Location:</strong> <span id="coordinates">Getting location...</span>
      </div>
      <div id="wplace-data">
        <strong>üè¢ Wplace Data:</strong> <span id="data-status">Loading...</span>
      </div>
      <div class="sensor-data">
        <strong>üì± Sensors:</strong>
        <div id="accelerometer-data">Accelerometer: --</div>
        <div id="gyroscope-data">Gyroscope: --</div>
        <div id="compass-data">Compass: --</div>
        <div id="orientation-data">Orientation: --</div>
        <div id="motion-data">Motion: --</div>
        <div id="light-data">Light: --</div>
        <div id="proximity-data">Proximity: --</div>
      </div>
    </div>

    <div class="sensor-indicator">
      <div>üìä Sensors</div>
      <div>
        <span class="sensor-dot sensor-unknown" id="acc-dot"></span>
        <span class="sensor-dot sensor-unknown" id="gyro-dot"></span>
        <span class="sensor-dot sensor-unknown" id="compass-dot"></span>
        <span class="sensor-dot sensor-unknown" id="orient-dot"></span>
        <span class="sensor-dot sensor-unknown" id="motion-dot"></span>
      </div>
    </div>

    <div id="camera-controls">
      <button class="ios-button" onclick="switchCamera()">üì∑ Switch Camera</button>
      <button class="ios-button" onclick="refreshLocation()">üîÑ Refresh</button>
      <button class="ios-button" onclick="testCameraAccess()">üì± Test Camera</button>
      <button class="ios-button" onclick="toggleSensorDisplay()">üìä Toggle Sensors</button>
             <button class="ios-button" onclick="toggleCameraFeed()">üëÅÔ∏è Show Camera</button>
       <button class="ios-button" onclick="testCompassTrigger()">üß≠ Test Compass Trigger</button>
    </div>

    <div id="camera-status">
      <div id="camera-message">Camera Status</div>
      <button class="ios-button" onclick="hideCameraStatus()" style="margin-top: 15px;">OK</button>
    </div>

    <a-scene embedded arjs="sourceType: webcam; sourceWidth: 1280; sourceHeight: 720; displayWidth: 1280; displayHeight: 720; facingMode: environment; debugUIEnabled: false;">

      <!-- AR content will be dynamically added here -->
      <a-entity id="ar-content"></a-entity>

      <!-- Camera entity -->
      <a-entity camera></a-entity>
    </a-scene>

    <script>
      let currentLocation = null;
      let wplaceData = null;
      let isFrontCamera = false;
      let sensorsVisible = true;
      let cameraFeedVisible = false;
      let sensorData = {
        accelerometer: { x: 0, y: 0, z: 0, active: false },
        gyroscope: { x: 0, y: 0, z: 0, active: false },
        compass: { heading: 0, active: false },
        orientation: { alpha: 0, beta: 0, gamma: 0, active: false },
        motion: { x: 0, y: 0, z: 0, active: false },
        light: { level: 0, active: false },
        proximity: { distance: 0, active: false }
      };

             // Toggle camera feed visibility for debugging
       function toggleCameraFeed() {
         cameraFeedVisible = !cameraFeedVisible;
         const cameraFeed = document.getElementById('camera-feed');
         const arScene = document.querySelector('a-scene');
         
         if (cameraFeedVisible) {
           // Start camera stream for debug mode
           if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
             navigator.mediaDevices.getUserMedia({ 
               video: { 
                 facingMode: 'environment',
                 width: { ideal: 1280 },
                 height: { ideal: 720 }
               } 
             })
             .then(function(stream) {
               cameraFeed.srcObject = stream;
               cameraFeed.style.display = 'block';
               arScene.style.display = 'none';
               document.getElementById('data-status').textContent = 'üëÅÔ∏è Camera Feed Visible (Debug Mode)';
               
               // Store stream reference to stop it later
               window.debugCameraStream = stream;
             })
             .catch(function(error) {
               console.error('Camera error in debug mode:', error);
               document.getElementById('data-status').textContent = '‚ùå Camera error in debug mode';
               cameraFeedVisible = false;
             });
           }
         } else {
           // Stop camera stream and return to AR mode
           if (window.debugCameraStream) {
             window.debugCameraStream.getTracks().forEach(track => track.stop());
             window.debugCameraStream = null;
           }
           cameraFeed.style.display = 'none';
           arScene.style.display = 'block';
           document.getElementById('data-status').textContent = '‚úÖ AR Mode Active';
         }
       }

      // Toggle sensor display
      function toggleSensorDisplay() {
        sensorsVisible = !sensorsVisible;
        const sensorPanel = document.querySelector('.sensor-indicator');
        const sensorDataDivs = document.querySelectorAll('.sensor-data');
        
        if (sensorsVisible) {
          sensorPanel.style.display = 'block';
          sensorDataDivs.forEach(div => div.style.display = 'block');
        } else {
          sensorPanel.style.display = 'none';
          sensorDataDivs.forEach(div => div.style.display = 'none');
        }
      }

      // Initialize all available sensors
      function initializeSensors() {
        console.log('Initializing sensors...');
        
        // Accelerometer
        if (window.DeviceMotionEvent) {
          window.addEventListener('devicemotion', function(event) {
            sensorData.accelerometer.x = event.accelerationIncludingGravity.x || 0;
            sensorData.accelerometer.y = event.accelerationIncludingGravity.y || 0;
            sensorData.accelerometer.z = event.accelerationIncludingGravity.z || 0;
            sensorData.accelerometer.active = true;
            
            updateSensorDisplay('accelerometer');
            updateSensorDot('acc-dot', true);
          });
        }

        // Gyroscope
        if (window.DeviceOrientationEvent) {
          window.addEventListener('deviceorientation', function(event) {
            sensorData.gyroscope.x = event.rotationRate.alpha || 0;
            sensorData.gyroscope.y = event.rotationRate.beta || 0;
            sensorData.gyroscope.z = event.rotationRate.gamma || 0;
            sensorData.gyroscope.active = true;
            
            updateSensorDisplay('gyroscope');
            updateSensorDot('gyro-dot', true);
          });
        }

                 // Compass
         if (window.DeviceOrientationEvent) {
           window.addEventListener('deviceorientation', function(event) {
             if (event.webkitCompassHeading !== undefined) {
               sensorData.compass.heading = event.webkitCompassHeading;
               sensorData.compass.active = true;
               updateSensorDisplay('compass');
               
               // Update compass dot with special trigger indication
               const heading = event.webkitCompassHeading;
               if (heading >= 100 && heading <= 150) {
                 updateSensorDot('compass-dot', 'triggered'); // Special state for triggered
               } else {
                 updateSensorDot('compass-dot', true); // Normal active state
               }
               
               // Check for special compass-triggered content
               checkCompassForSpecialContent();
             }
           });
         }

        // Device Orientation
        if (window.DeviceOrientationEvent) {
          window.addEventListener('deviceorientation', function(event) {
            sensorData.orientation.alpha = event.alpha || 0;
            sensorData.orientation.beta = event.beta || 0;
            sensorData.orientation.gamma = event.gamma || 0;
            sensorData.orientation.active = true;
            
            updateSensorDisplay('orientation');
            updateSensorDot('orient-dot', true);
          });
        }

        // Motion Sensors (iOS 13+)
        if (window.DeviceMotionEvent && 'requestPermission' in DeviceMotionEvent) {
          DeviceMotionEvent.requestPermission().then(function(permissionState) {
            if (permissionState === 'granted') {
              window.addEventListener('devicemotion', function(event) {
                if (event.rotationRate) {
                  sensorData.motion.x = event.rotationRate.alpha || 0;
                  sensorData.motion.y = event.rotationRate.beta || 0;
                  sensorData.motion.z = event.rotationRate.gamma || 0;
                  sensorData.motion.active = true;
                  
                  updateSensorDisplay('motion');
                  updateSensorDot('motion-dot', true);
                }
              });
            }
          });
        }

        // Ambient Light Sensor (if available)
        if ('AmbientLightSensor' in window) {
          try {
            const lightSensor = new AmbientLightSensor();
            lightSensor.addEventListener('reading', function() {
              sensorData.light.level = lightSensor.illuminance;
              sensorData.light.active = true;
              updateSensorDisplay('light');
            });
            lightSensor.start();
          } catch (e) {
            console.log('Light sensor not available:', e);
          }
        }

        // Proximity Sensor (if available)
        if ('ProximitySensor' in window) {
          try {
            const proximitySensor = new ProximitySensor();
            proximitySensor.addEventListener('reading', function() {
              sensorData.proximity.distance = proximitySensor.distance;
              sensorData.proximity.active = true;
              updateSensorDisplay('proximity');
            });
            proximitySensor.start();
          } catch (e) {
            console.log('Proximity sensor not available:', e);
          }
        }

        // Touch and gesture sensors
        let touchStartX = 0, touchStartY = 0;
        let touchEndX = 0, touchEndY = 0;
        
        document.addEventListener('touchstart', function(e) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchend', function(e) {
          touchEndX = e.changedTouches[0].clientX;
          touchEndY = e.changedTouches[0].clientY;
          handleGesture();
        });

        // Battery status (if available)
        if ('getBattery' in navigator) {
          navigator.getBattery().then(function(battery) {
            battery.addEventListener('levelchange', function() {
              console.log('Battery level:', battery.level * 100 + '%');
            });
          });
        }

        // Network information (if available)
        if ('connection' in navigator) {
          navigator.connection.addEventListener('change', function() {
            console.log('Network type:', navigator.connection.effectiveType);
          });
        }
      }

             // Update sensor display
       function updateSensorDisplay(sensorType) {
         const data = sensorData[sensorType];
         if (!data) return;
 
         let displayText = '';
         switch(sensorType) {
           case 'accelerometer':
             displayText = `X:${data.x.toFixed(2)} Y:${data.y.toFixed(2)} Z:${data.z.toFixed(2)}`;
             break;
           case 'gyroscope':
             displayText = `X:${data.x.toFixed(2)} Y:${data.y.toFixed(2)} Z:${data.z.toFixed(2)}`;
             break;
           case 'compass':
             const heading = data.heading;
             let compassStatus = '';
             if (heading >= 100 && heading <= 150) {
               compassStatus = ' üéØ TRIGGERED!';
             }
             displayText = `${heading.toFixed(1)}¬∞${compassStatus}`;
             break;
           case 'orientation':
             displayText = `Œ±:${data.alpha.toFixed(1)} Œ≤:${data.beta.toFixed(1)} Œ≥:${data.gamma.toFixed(1)}`;
             break;
           case 'motion':
             displayText = `X:${data.x.toFixed(2)} Y:${data.y.toFixed(2)} Z:${data.z.toFixed(2)}`;
             break;
           case 'light':
             displayText = `${data.level.toFixed(1)} lux`;
             break;
           case 'proximity':
             displayText = `${data.distance.toFixed(2)} cm`;
             break;
         }
 
         const element = document.getElementById(sensorType + '-data');
         if (element) {
           element.textContent = `${sensorType.charAt(0).toUpperCase() + sensorType.slice(1)}: ${displayText}`;
         }
       }

             // Update sensor indicator dots
       function updateSensorDot(dotId, active) {
         const dot = document.getElementById(dotId);
         if (dot) {
           if (active === 'triggered') {
             dot.className = 'sensor-dot sensor-triggered';
           } else {
             dot.className = `sensor-dot ${active ? 'sensor-active' : 'sensor-inactive'}`;
           }
         }
       }

      // Handle touch gestures
      function handleGesture() {
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          if (deltaX > 50) {
            console.log('Swipe right detected');
            // Add AR content based on swipe
          } else if (deltaX < -50) {
            console.log('Swipe left detected');
            // Add AR content based on swipe
          }
        } else {
          if (deltaY > 50) {
            console.log('Swipe down detected');
            // Add AR content based on swipe
          } else if (deltaY < -50) {
            console.log('Swipe up detected');
            // Add AR content based on swipe
          }
        }
      }

              // Test camera access (similar to camera-test.html)
        function testCameraAccess() {
          const statusDiv = document.getElementById('camera-status');
          const messageDiv = document.getElementById('camera-message');
          
          statusDiv.style.display = 'block';
          messageDiv.textContent = 'Testing camera access...';
          
          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ 
              video: { 
                facingMode: 'environment',
                width: { ideal: 1280 },
                height: { ideal: 720 }
              } 
            })
          .then(function(stream) {
            messageDiv.textContent = '‚úÖ Camera working! AR should work now.';
            
                         // Also set the hidden camera feed for debugging (but don't stop it)
             const cameraFeed = document.getElementById('camera-feed');
             if (!cameraFeedVisible) {
               cameraFeed.srcObject = stream;
             }
             
             // Stop the test stream after a delay
             setTimeout(() => {
               stream.getTracks().forEach(track => track.stop());
             }, 2000);
          })
          .catch(function(error) {
            console.error('Camera error:', error);
            let errorMessage = 'Camera error: ' + error.message;
            
            if (error.name === 'NotAllowedError') {
              errorMessage = '‚ùå Camera access denied. Please allow camera access in your browser settings.';
            } else if (error.name === 'NotFoundError') {
              errorMessage = '‚ùå No camera found on this device.';
            } else if (error.name === 'NotReadableError') {
              errorMessage = '‚ùå Camera is already in use by another application.';
            }
            
            messageDiv.textContent = errorMessage;
          });
        } else {
          messageDiv.textContent = '‚ùå getUserMedia not supported in this browser';
        }
      }

      function hideCameraStatus() {
        document.getElementById('camera-status').style.display = 'none';
      }

      // Get user's location
      function getLocation() {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            function(position) {
              currentLocation = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                altitude: position.coords.altitude,
                heading: position.coords.heading,
                speed: position.coords.speed
              };
              
              document.getElementById('coordinates').textContent = 
                `${currentLocation.latitude.toFixed(6)}, ${currentLocation.longitude.toFixed(6)}`;
              
              // Create AR content based on location and sensors
              createARContentFromLocationAndSensors(currentLocation);
              
            },
            function(error) {
              console.error('Error getting location:', error);
              document.getElementById('coordinates').textContent = 'Location access denied';
              document.getElementById('data-status').textContent = 'Cannot fetch data without location';
            },
            {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 300000
            }
          );
        } else {
          document.getElementById('coordinates').textContent = 'Geolocation not supported';
        }
      }

              // Switch between front and back camera
        function switchCamera() {
          isFrontCamera = !isFrontCamera;
          const facingMode = isFrontCamera ? 'user' : 'environment';
          
          // Show which camera is active
          const status = document.getElementById('data-status');
          status.textContent = isFrontCamera ? 'üì± Front Camera' : 'üì∑ Back Camera';
          status.className = 'success';
          
          // Update AR.js facing mode
          const scene = document.querySelector('a-scene');
          const arjs = scene.getAttribute('arjs');
          arjs.facingMode = facingMode;
          scene.setAttribute('arjs', arjs);
          
          // Reload the AR scene with new camera
          location.reload();
        }

      // Refresh location manually
      function refreshLocation() {
        document.getElementById('coordinates').textContent = 'Refreshing...';
        document.getElementById('data-status').textContent = 'Refreshing...';
        getLocation();
      }

      // Create AR content based on location and sensors
      function createARContentFromLocationAndSensors(location) {
        const arContent = document.getElementById('ar-content');
        arContent.innerHTML = ''; // Clear existing content
        
        // Create location-based AR content
        const textEntity = document.createElement('a-text');
        textEntity.setAttribute('value', `Location: ${location.latitude.toFixed(4)}, ${location.longitude.toFixed(4)}`);
        textEntity.setAttribute('position', '0 2 -3');
        textEntity.setAttribute('align', 'center');
        textEntity.setAttribute('width', '4');
        textEntity.setAttribute('color', '#ffffff');
        textEntity.setAttribute('font', 'kelsans');
        
        arContent.appendChild(textEntity);
        
        // Add sensor-based AR content
        if (sensorData.accelerometer.active) {
          const accelEntity = document.createElement('a-text');
          accelEntity.setAttribute('value', `Motion: ${sensorData.accelerometer.x.toFixed(1)}, ${sensorData.accelerometer.y.toFixed(1)}`);
          accelEntity.setAttribute('position', '0 1.5 -3');
          accelEntity.setAttribute('align', 'center');
          accelEntity.setAttribute('width', '3');
          accelEntity.setAttribute('color', '#00ff00');
          accelEntity.setAttribute('font', 'kelsans');
          
          arContent.appendChild(accelEntity);
        }
        
        if (sensorData.compass.active) {
          const compassEntity = document.createElement('a-text');
          compassEntity.setAttribute('value', `Heading: ${sensorData.compass.heading.toFixed(0)}¬∞`);
          compassEntity.setAttribute('position', '0 1 -3');
          compassEntity.setAttribute('align', 'center');
          compassEntity.setAttribute('width', '3');
          compassEntity.setAttribute('color', '#ffff00');
          compassEntity.setAttribute('font', 'kelsans');
          
          arContent.appendChild(compassEntity);
        }
        
        // Add a background plane for better visibility
        const background = document.createElement('a-plane');
        background.setAttribute('position', '0 1.5 -3.1');
        background.setAttribute('width', '4.5');
        background.setAttribute('height', '2.5');
        background.setAttribute('color', '#000000');
        background.setAttribute('opacity', '0.7');
        
        arContent.appendChild(background);
        
                 // Update status
         document.getElementById('data-status').textContent = '‚úÖ AR Content Ready!';
         document.getElementById('data-status').className = 'success';
         
         // Check compass heading for special AR content
         checkCompassForSpecialContent();
       }
       
       // Check compass heading and show special AR content
       function checkCompassForSpecialContent() {
         if (sensorData.compass.active) {
           const heading = sensorData.compass.heading;
           
           // Check if heading is between 100-150 degrees
           if (heading >= 100 && heading <= 150) {
             showCompassTriggeredImage();
           } else {
             hideCompassTriggeredImage();
           }
         }
       }
       
       // Show the compass-triggered image
       function showCompassTriggeredImage() {
         let compassImage = document.getElementById('compass-triggered-image');
         
         // Create image if it doesn't exist
         if (!compassImage) {
           compassImage = document.createElement('a-image');
           compassImage.setAttribute('id', 'compass-triggered-image');
           compassImage.setAttribute('src', 'testimg.jpg');
           compassImage.setAttribute('position', '0 3 -5');
           compassImage.setAttribute('width', '2');
           compassImage.setAttribute('height', '2');
           compassImage.setAttribute('rotation', '0 0 0');
           
           // Add to AR scene
           const arContent = document.getElementById('ar-content');
           arContent.appendChild(compassImage);
           
           // Update status
           document.getElementById('data-status').textContent = 'üéØ Compass Image Active (100-150¬∞)';
           document.getElementById('data-status').className = 'success';
         }
       }
       
       // Hide the compass-triggered image
       function hideCompassTriggeredImage() {
         const compassImage = document.getElementById('compass-triggered-image');
         if (compassImage) {
           compassImage.remove();
           
           // Update status back to normal
           document.getElementById('data-status').textContent = '‚úÖ AR Content Ready!';
           document.getElementById('data-status').className = 'success';
         }
       }
       
       // Test compass trigger manually
       function testCompassTrigger() {
         const statusDiv = document.getElementById('camera-status');
         const messageDiv = document.getElementById('camera-message');
         
         statusDiv.style.display = 'block';
         
         if (sensorData.compass.active) {
           const heading = sensorData.compass.heading;
           if (heading >= 100 && heading <= 150) {
             messageDiv.textContent = `üéØ Compass Triggered! (${heading.toFixed(1)}¬∞) - Image should be visible`;
             showCompassTriggeredImage();
           } else {
             messageDiv.textContent = `üß≠ Compass: ${heading.toFixed(1)}¬∞ - Not in trigger range (100-150¬∞)`;
           }
         } else {
           messageDiv.textContent = '‚ùå Compass not active - rotate device to activate';
         }
       }

              // Initialize the app when the page loads
        window.addEventListener('load', function() {
          console.log('AR App loaded successfully!');
          
          // iOS-specific initialization
          if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
            console.log('iOS device detected - optimizing for iOS');
          }
          
          // Initialize all sensors
          initializeSensors();
          
          // Get location first
          getLocation();
          
          // Test camera access after a short delay
          setTimeout(testCameraAccess, 1000);
          
          // Update status to show back camera is active
          document.getElementById('data-status').textContent = 'üì∑ Back Camera Active';
          document.getElementById('data-status').className = 'success';
          
          // Update sensor data display periodically
          setInterval(function() {
            Object.keys(sensorData).forEach(sensorType => {
              if (sensorData[sensorType].active) {
                updateSensorDisplay(sensorType);
              }
            });
          }, 100);
        });

      // Handle iOS-specific events
      document.addEventListener('touchstart', function(e) {
        // Prevent zoom on double tap
        if (e.touches.length > 1) {
          e.preventDefault();
        }
      }, { passive: false });

      // Handle device orientation changes
      window.addEventListener('orientationchange', function() {
        setTimeout(function() {
          // Refresh the view after orientation change
          window.scrollTo(0, 0);
        }, 100);
      });

      // Update location periodically (every 30 seconds)
      setInterval(getLocation, 30000);
    </script>
  </body>
</html>
