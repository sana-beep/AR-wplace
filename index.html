<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Wplace AR - iOS (Multi-Sensor)</title>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
      }
      #info-panel {
        position: fixed;
        top: env(safe-area-inset-top, 20px);
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px;
        border-radius: 15px;
        z-index: 1000;
        max-width: 350px;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        font-size: 12px;
        line-height: 1.3;
      }
      #location-info {
        margin-bottom: 10px;
      }
      #wplace-data {
        font-size: 12px;
        line-height: 1.4;
      }
      .sensor-data {
        margin: 5px 0;
        font-size: 11px;
        opacity: 0.9;
      }
      .loading {
        color: #ffd700;
      }
      .error {
        color: #ff6b6b;
      }
      .success {
        color: #34C759;
      }
      .ios-button {
        background: #007AFF;
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 25px;
        font-size: 16px;
        font-weight: 600;
        margin: 10px 5px;
        cursor: pointer;
        -webkit-appearance: none;
      }
      .ios-button:active {
        background: #0056CC;
        transform: scale(0.95);
      }
             #camera-controls {
         position: fixed;
         bottom: env(safe-area-inset-bottom, 20px);
         right: 20px;
         z-index: 1000;
         text-align: center;
       }
       
       #menu-toggle {
         background: #007AFF;
         color: white;
         border: none;
         padding: 15px;
         border-radius: 50%;
         font-size: 20px;
         font-weight: 600;
         cursor: pointer;
         -webkit-appearance: none;
         box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
         width: 60px;
         height: 60px;
         display: flex;
         align-items: center;
         justify-content: center;
       }
       
       #menu-toggle:active {
         background: #0056CC;
         transform: scale(0.95);
       }
       
       #menu-panel {
         position: fixed;
         bottom: env(safe-area-inset-bottom, 90px);
         right: 20px;
         background: rgba(0, 0, 0, 0.9);
         border-radius: 15px;
         padding: 15px;
         z-index: 999;
         display: none;
         backdrop-filter: blur(10px);
         -webkit-backdrop-filter: blur(10px);
         min-width: 200px;
       }
       
       .menu-item {
         background: transparent;
         color: white;
         border: none;
         padding: 12px 15px;
         border-radius: 10px;
         font-size: 14px;
         font-weight: 500;
         margin: 5px 0;
         cursor: pointer;
         -webkit-appearance: none;
         text-align: left;
         width: 100%;
         transition: background 0.2s;
       }
       
       .menu-item:hover, .menu-item:active {
         background: rgba(255, 255, 255, 0.1);
       }
       
       .menu-divider {
         height: 1px;
         background: rgba(255, 255, 255, 0.2);
         margin: 10px 0;
       }
       
       .range-input {
         background: rgba(255, 255, 255, 0.1);
         border: 1px solid rgba(255, 255, 255, 0.3);
         color: white;
         padding: 8px 12px;
         border-radius: 8px;
         font-size: 14px;
         width: 60px;
         margin: 0 5px;
         text-align: center;
       }
       
       .range-input:focus {
         outline: none;
         border-color: #007AFF;
       }
       
       .range-label {
         color: rgba(255, 255, 255, 0.8);
         font-size: 12px;
         margin: 5px 0;
       }
      #camera-status {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 15px;
        z-index: 2000;
        text-align: center;
        display: none;
      }
      .sensor-indicator {
        position: fixed;
        top: env(safe-area-inset-top, 20px);
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 10px;
        z-index: 1000;
        font-size: 11px;
        text-align: center;
      }
      .sensor-dot {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin: 0 2px;
      }
             .sensor-active { background: #34C759; }
       .sensor-inactive { background: #FF3B30; }
       .sensor-unknown { background: #FF9500; }
              .sensor-triggered { background: #FFD700; animation: pulse 1s infinite; }
       
       @keyframes pulse {
         0% { transform: scale(1); }
         50% { transform: scale(1.2); }
         100% { transform: scale(1); }
       }
       
       #camera-feed {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        object-fit: cover;
        display: none;
      }
    </style>
  </head>
  <body>
    <!-- Hidden camera feed for debugging -->
    <video id="camera-feed" autoplay playsinline muted></video>

    <div id="info-panel">
      <div id="location-info">
        <strong>üìç Location:</strong> <span id="coordinates">Getting location...</span>
      </div>
      <div id="wplace-data">
        <strong>üè¢ Wplace Data:</strong> <span id="data-status">Loading...</span>
      </div>
      <div class="sensor-data">
        <strong>üì± Sensors:</strong>
        <div id="accelerometer-data">Accelerometer: --</div>
        <div id="gyroscope-data">Gyroscope: --</div>
        <div id="compass-data">Compass: --</div>
        <div id="orientation-data">Orientation: --</div>
        <div id="motion-data">Motion: --</div>
        <div id="light-data">Light: --</div>
        <div id="proximity-data">Proximity: --</div>
      </div>
    </div>

    <div class="sensor-indicator">
      <div>üìä Sensors</div>
      <div>
        <span class="sensor-dot sensor-unknown" id="acc-dot"></span>
        <span class="sensor-dot sensor-unknown" id="gyro-dot"></span>
        <span class="sensor-dot sensor-unknown" id="compass-dot"></span>
        <span class="sensor-dot sensor-unknown" id="orient-dot"></span>
        <span class="sensor-dot sensor-unknown" id="motion-dot"></span>
      </div>
    </div>

         <div id="camera-controls">
       <button id="menu-toggle" onclick="toggleMenu()">‚öôÔ∏è</button>
       
       <div id="menu-panel">
         <div class="range-label">üß≠ Compass Range (degrees):</div>
         <div style="text-align: center; margin: 10px 0;">
           <input type="number" id="min-range" class="range-input" value="100" min="0" max="359">
           <span style="color: white;">to</span>
           <input type="number" id="max-range" class="range-input" value="150" min="0" max="359">
         </div>
         <button class="menu-item" onclick="updateCompassRange()">‚úÖ Update Range</button>
         
         <div class="menu-divider"></div>
         
         <button class="menu-item" onclick="switchCamera()">üì∑ Switch Camera</button>
         <button class="menu-item" onclick="refreshLocation()">üîÑ Refresh Location</button>
         <button class="menu-item" onclick="testCameraAccess()">üì± Test Camera</button>
         <button class="menu-item" onclick="toggleSensorDisplay()">üìä Toggle Sensors</button>
         <button class="menu-item" onclick="toggleCameraFeed()">üëÅÔ∏è Show Camera</button>
         <button class="menu-item" onclick="testCompassTrigger()">üß≠ Test Compass</button>
       <button class="menu-item" onclick="debugCreate3DObject()">üîß Debug 3D Object</button>
         
         <div class="menu-divider"></div>
         
         <button class="menu-item" onclick="hideMenu()">‚ùå Close Menu</button>
       </div>
     </div>

    <div id="camera-status">
      <div id="camera-message">Camera Status</div>
      <button class="ios-button" onclick="hideCameraStatus()" style="margin-top: 15px;">OK</button>
    </div>

    <a-scene embedded arjs="sourceType: webcam; sourceWidth: 1280; sourceHeight: 720; displayWidth: 1280; displayHeight: 720; facingMode: environment; debugUIEnabled: false;">

      <!-- AR content will be dynamically added here -->
      <a-entity id="ar-content"></a-entity>

      <!-- Camera entity -->
      <a-entity camera></a-entity>
    </a-scene>

    <script>
             let currentLocation = null;
       let wplaceData = null;
       let isFrontCamera = false;
       let sensorsVisible = true;
       let cameraFeedVisible = false;
       let compassRange = { min: 100, max: 150 };
      let sensorData = {
        accelerometer: { x: 0, y: 0, z: 0, active: false },
        gyroscope: { x: 0, y: 0, z: 0, active: false },
        compass: { heading: 0, active: false },
        orientation: { alpha: 0, beta: 0, gamma: 0, active: false },
        motion: { x: 0, y: 0, z: 0, active: false },
        light: { level: 0, active: false },
        proximity: { distance: 0, active: false }
      };

             // Toggle camera feed visibility for debugging
       function toggleCameraFeed() {
         cameraFeedVisible = !cameraFeedVisible;
         const cameraFeed = document.getElementById('camera-feed');
         const arScene = document.querySelector('a-scene');
         
         if (cameraFeedVisible) {
           // Start camera stream for debug mode
           if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
             navigator.mediaDevices.getUserMedia({ 
               video: { 
                 facingMode: 'environment',
                 width: { ideal: 1280 },
                 height: { ideal: 720 }
               } 
             })
             .then(function(stream) {
               cameraFeed.srcObject = stream;
               cameraFeed.style.display = 'block';
               arScene.style.display = 'none';
               document.getElementById('data-status').textContent = 'üëÅÔ∏è Camera Feed Visible (Debug Mode)';
               
               // Store stream reference to stop it later
               window.debugCameraStream = stream;
             })
             .catch(function(error) {
               console.error('Camera error in debug mode:', error);
               document.getElementById('data-status').textContent = '‚ùå Camera error in debug mode';
               cameraFeedVisible = false;
             });
           }
         } else {
           // Stop camera stream and return to AR mode
           if (window.debugCameraStream) {
             window.debugCameraStream.getTracks().forEach(track => track.stop());
             window.debugCameraStream = null;
           }
           cameraFeed.style.display = 'none';
           arScene.style.display = 'block';
           document.getElementById('data-status').textContent = '‚úÖ AR Mode Active';
         }
       }

      // Toggle sensor display
      function toggleSensorDisplay() {
        sensorsVisible = !sensorsVisible;
        const sensorPanel = document.querySelector('.sensor-indicator');
        const sensorDataDivs = document.querySelectorAll('.sensor-data');
        
        if (sensorsVisible) {
          sensorPanel.style.display = 'block';
          sensorDataDivs.forEach(div => div.style.display = 'block');
        } else {
          sensorPanel.style.display = 'none';
          sensorDataDivs.forEach(div => div.style.display = 'none');
        }
      }

      // Initialize all available sensors
      function initializeSensors() {
        console.log('Initializing sensors...');
        
        // Accelerometer
        if (window.DeviceMotionEvent) {
          window.addEventListener('devicemotion', function(event) {
            sensorData.accelerometer.x = event.accelerationIncludingGravity.x || 0;
            sensorData.accelerometer.y = event.accelerationIncludingGravity.y || 0;
            sensorData.accelerometer.z = event.accelerationIncludingGravity.z || 0;
            sensorData.accelerometer.active = true;
            
            updateSensorDisplay('accelerometer');
            updateSensorDot('acc-dot', true);
          });
        }

        // Gyroscope
        if (window.DeviceOrientationEvent) {
          window.addEventListener('deviceorientation', function(event) {
            sensorData.gyroscope.x = event.rotationRate.alpha || 0;
            sensorData.gyroscope.y = event.rotationRate.beta || 0;
            sensorData.gyroscope.z = event.rotationRate.gamma || 0;
            sensorData.gyroscope.active = true;
            
            updateSensorDisplay('gyroscope');
            updateSensorDot('gyro-dot', true);
          });
        }

                 // Compass
         if (window.DeviceOrientationEvent) {
           window.addEventListener('deviceorientation', function(event) {
             if (event.webkitCompassHeading !== undefined) {
               sensorData.compass.heading = event.webkitCompassHeading;
               sensorData.compass.active = true;
               updateSensorDisplay('compass');
               
               // Update compass dot with special trigger indication
               const heading = event.webkitCompassHeading;
               if (heading >= compassRange.min && heading <= compassRange.max) {
                 updateSensorDot('compass-dot', 'triggered'); // Special state for triggered
               } else {
                 updateSensorDot('compass-dot', true); // Normal active state
               }
               
               // Check for special compass-triggered content
               checkCompassForSpecialContent();
             }
           });
         }

        // Device Orientation
        if (window.DeviceOrientationEvent) {
          window.addEventListener('deviceorientation', function(event) {
            sensorData.orientation.alpha = event.alpha || 0;
            sensorData.orientation.beta = event.beta || 0;
            sensorData.orientation.gamma = event.gamma || 0;
            sensorData.orientation.active = true;
            
            updateSensorDisplay('orientation');
            updateSensorDot('orient-dot', true);
          });
        }

        // Motion Sensors (iOS 13+)
        if (window.DeviceMotionEvent && 'requestPermission' in DeviceMotionEvent) {
          DeviceMotionEvent.requestPermission().then(function(permissionState) {
            if (permissionState === 'granted') {
              window.addEventListener('devicemotion', function(event) {
                if (event.rotationRate) {
                  sensorData.motion.x = event.rotationRate.alpha || 0;
                  sensorData.motion.y = event.rotationRate.beta || 0;
                  sensorData.motion.z = event.rotationRate.gamma || 0;
                  sensorData.motion.active = true;
                  
                  updateSensorDisplay('motion');
                  updateSensorDot('motion-dot', true);
                }
              });
            }
          });
        }

        // Ambient Light Sensor (if available)
        if ('AmbientLightSensor' in window) {
          try {
            const lightSensor = new AmbientLightSensor();
            lightSensor.addEventListener('reading', function() {
              sensorData.light.level = lightSensor.illuminance;
              sensorData.light.active = true;
              updateSensorDisplay('light');
            });
            lightSensor.start();
          } catch (e) {
            console.log('Light sensor not available:', e);
          }
        }

        // Proximity Sensor (if available)
        if ('ProximitySensor' in window) {
          try {
            const proximitySensor = new ProximitySensor();
            proximitySensor.addEventListener('reading', function() {
              sensorData.proximity.distance = proximitySensor.distance;
              sensorData.proximity.active = true;
              updateSensorDisplay('proximity');
            });
            proximitySensor.start();
          } catch (e) {
            console.log('Proximity sensor not available:', e);
          }
        }

        // Touch and gesture sensors
        let touchStartX = 0, touchStartY = 0;
        let touchEndX = 0, touchEndY = 0;
        
        document.addEventListener('touchstart', function(e) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchend', function(e) {
          touchEndX = e.changedTouches[0].clientX;
          touchEndY = e.changedTouches[0].clientY;
          handleGesture();
        });

        // Battery status (if available)
        if ('getBattery' in navigator) {
          navigator.getBattery().then(function(battery) {
            battery.addEventListener('levelchange', function() {
              console.log('Battery level:', battery.level * 100 + '%');
            });
          });
        }

        // Network information (if available)
        if ('connection' in navigator) {
          navigator.connection.addEventListener('change', function() {
            console.log('Network type:', navigator.connection.effectiveType);
          });
        }
      }

             // Update sensor display
       function updateSensorDisplay(sensorType) {
         const data = sensorData[sensorType];
         if (!data) return;
 
         let displayText = '';
         switch(sensorType) {
           case 'accelerometer':
             displayText = `X:${data.x.toFixed(2)} Y:${data.y.toFixed(2)} Z:${data.z.toFixed(2)}`;
             break;
           case 'gyroscope':
             displayText = `X:${data.x.toFixed(2)} Y:${data.y.toFixed(2)} Z:${data.z.toFixed(2)}`;
             break;
           case 'compass':
             const heading = data.heading;
             let compassStatus = '';
             if (heading >= compassRange.min && heading <= compassRange.max) {
               compassStatus = ' üéØ TRIGGERED!';
             }
             displayText = `${heading.toFixed(1)}¬∞${compassStatus}`;
             break;
           case 'orientation':
             displayText = `Œ±:${data.alpha.toFixed(1)} Œ≤:${data.beta.toFixed(1)} Œ≥:${data.gamma.toFixed(1)}`;
             break;
           case 'motion':
             displayText = `X:${data.x.toFixed(2)} Y:${data.y.toFixed(2)} Z:${data.z.toFixed(2)}`;
             break;
           case 'light':
             displayText = `${data.level.toFixed(1)} lux`;
             break;
           case 'proximity':
             displayText = `${data.distance.toFixed(2)} cm`;
             break;
         }
 
         const element = document.getElementById(sensorType + '-data');
         if (element) {
           element.textContent = `${sensorType.charAt(0).toUpperCase() + sensorType.slice(1)}: ${displayText}`;
         }
       }

             // Update sensor indicator dots
       function updateSensorDot(dotId, active) {
         const dot = document.getElementById(dotId);
         if (dot) {
           if (active === 'triggered') {
             dot.className = 'sensor-dot sensor-triggered';
           } else {
             dot.className = `sensor-dot ${active ? 'sensor-active' : 'sensor-inactive'}`;
           }
         }
       }

      // Handle touch gestures
      function handleGesture() {
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          if (deltaX > 50) {
            console.log('Swipe right detected');
            // Add AR content based on swipe
          } else if (deltaX < -50) {
            console.log('Swipe left detected');
            // Add AR content based on swipe
          }
        } else {
          if (deltaY > 50) {
            console.log('Swipe down detected');
            // Add AR content based on swipe
          } else if (deltaY < -50) {
            console.log('Swipe up detected');
            // Add AR content based on swipe
          }
        }
      }

              // Test camera access (similar to camera-test.html)
        function testCameraAccess() {
          const statusDiv = document.getElementById('camera-status');
          const messageDiv = document.getElementById('camera-message');
          
          statusDiv.style.display = 'block';
          messageDiv.textContent = 'Testing camera access...';
          
          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ 
              video: { 
                facingMode: 'environment',
                width: { ideal: 1280 },
                height: { ideal: 720 }
              } 
            })
          .then(function(stream) {
            messageDiv.textContent = '‚úÖ Camera working! AR should work now.';
            
                         // Also set the hidden camera feed for debugging (but don't stop it)
             const cameraFeed = document.getElementById('camera-feed');
             if (!cameraFeedVisible) {
               cameraFeed.srcObject = stream;
             }
             
             // Stop the test stream after a delay
             setTimeout(() => {
               stream.getTracks().forEach(track => track.stop());
             }, 2000);
          })
          .catch(function(error) {
            console.error('Camera error:', error);
            let errorMessage = 'Camera error: ' + error.message;
            
            if (error.name === 'NotAllowedError') {
              errorMessage = '‚ùå Camera access denied. Please allow camera access in your browser settings.';
            } else if (error.name === 'NotFoundError') {
              errorMessage = '‚ùå No camera found on this device.';
            } else if (error.name === 'NotReadableError') {
              errorMessage = '‚ùå Camera is already in use by another application.';
            }
            
            messageDiv.textContent = errorMessage;
          });
        } else {
          messageDiv.textContent = '‚ùå getUserMedia not supported in this browser';
        }
      }

      function hideCameraStatus() {
        document.getElementById('camera-status').style.display = 'none';
      }

      // Get user's location
      function getLocation() {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            function(position) {
              currentLocation = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                altitude: position.coords.altitude,
                heading: position.coords.heading,
                speed: position.coords.speed
              };
              
              document.getElementById('coordinates').textContent = 
                `${currentLocation.latitude.toFixed(6)}, ${currentLocation.longitude.toFixed(6)}`;
              
              // Create AR content based on location and sensors
              createARContentFromLocationAndSensors(currentLocation);
              
            },
            function(error) {
              console.error('Error getting location:', error);
              document.getElementById('coordinates').textContent = 'Location access denied';
              document.getElementById('data-status').textContent = 'Cannot fetch data without location';
            },
            {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 300000
            }
          );
        } else {
          document.getElementById('coordinates').textContent = 'Geolocation not supported';
        }
      }

              // Switch between front and back camera
        function switchCamera() {
          isFrontCamera = !isFrontCamera;
          const facingMode = isFrontCamera ? 'user' : 'environment';
          
          // Show which camera is active
          const status = document.getElementById('data-status');
          status.textContent = isFrontCamera ? 'üì± Front Camera' : 'üì∑ Back Camera';
          status.className = 'success';
          
          // Update AR.js facing mode
          const scene = document.querySelector('a-scene');
          const arjs = scene.getAttribute('arjs');
          arjs.facingMode = facingMode;
          scene.setAttribute('arjs', arjs);
          
          // Reload the AR scene with new camera
          location.reload();
        }

      // Refresh location manually
      function refreshLocation() {
        document.getElementById('coordinates').textContent = 'Refreshing...';
        document.getElementById('data-status').textContent = 'Refreshing...';
        getLocation();
      }

      // Create AR content based on location and sensors
      function createARContentFromLocationAndSensors(location) {
        const arContent = document.getElementById('ar-content');
        arContent.innerHTML = ''; // Clear existing content
        
        // Create location-based AR content
        const textEntity = document.createElement('a-text');
        textEntity.setAttribute('value', `Location: ${location.latitude.toFixed(4)}, ${location.longitude.toFixed(4)}`);
        textEntity.setAttribute('position', '0 2 -3');
        textEntity.setAttribute('align', 'center');
        textEntity.setAttribute('width', '4');
        textEntity.setAttribute('color', '#ffffff');
        textEntity.setAttribute('font', 'kelsans');
        
        arContent.appendChild(textEntity);
        
        // Add sensor-based AR content
        if (sensorData.accelerometer.active) {
          const accelEntity = document.createElement('a-text');
          accelEntity.setAttribute('value', `Motion: ${sensorData.accelerometer.x.toFixed(1)}, ${sensorData.accelerometer.y.toFixed(1)}`);
          accelEntity.setAttribute('position', '0 1.5 -3');
          accelEntity.setAttribute('align', 'center');
          accelEntity.setAttribute('width', '3');
          accelEntity.setAttribute('color', '#00ff00');
          accelEntity.setAttribute('font', 'kelsans');
          
          arContent.appendChild(accelEntity);
        }
        
        if (sensorData.compass.active) {
          const compassEntity = document.createElement('a-text');
          compassEntity.setAttribute('value', `Heading: ${sensorData.compass.heading.toFixed(0)}¬∞`);
          compassEntity.setAttribute('position', '0 1 -3');
          compassEntity.setAttribute('align', 'center');
          compassEntity.setAttribute('width', '3');
          compassEntity.setAttribute('color', '#ffff00');
          compassEntity.setAttribute('font', 'kelsans');
          
          arContent.appendChild(compassEntity);
        }
        
        // Add a background plane for better visibility
        const background = document.createElement('a-plane');
        background.setAttribute('position', '0 1.5 -3.1');
        background.setAttribute('width', '4.5');
        background.setAttribute('height', '2.5');
        background.setAttribute('color', '#000000');
        background.setAttribute('opacity', '0.7');
        
        arContent.appendChild(background);
        
                 // Update status
         document.getElementById('data-status').textContent = '‚úÖ AR Content Ready!';
         document.getElementById('data-status').className = 'success';
         
         // Check compass heading for special AR content
         checkCompassForSpecialContent();
       }
       
       // Check compass heading and show special AR content
       function checkCompassForSpecialContent() {
         if (sensorData.compass.active) {
           const heading = sensorData.compass.heading;
           
           // Check if heading is within custom range
           if (heading >= compassRange.min && heading <= compassRange.max) {
             showCompassTriggeredImage();
           } else {
             hideCompassTriggeredImage();
           }
         }
       }
       
       // Show the compass-triggered image
       function showCompassTriggeredImage() {
         let compassImage = document.getElementById('compass-triggered-image');
         
         // Create image if it doesn't exist
         if (!compassImage) {
           // Try multiple approaches for better visibility
           try {
             // Method 1: 3D Box with image texture
             compassImage = document.createElement('a-box');
             compassImage.setAttribute('id', 'compass-triggered-image');
             compassImage.setAttribute('position', '0 1.5 -2');
             compassImage.setAttribute('width', '2');
             compassImage.setAttribute('height', '2');
             compassImage.setAttribute('depth', '0.2');
             compassImage.setAttribute('rotation', '0 0 0');
             compassImage.setAttribute('color', '#ffffff');
             compassImage.setAttribute('material', 'src: testimg.jpg; repeat: 1 1');
             
             console.log('üéØ Method 1: 3D Box created');
           } catch (e) {
             console.log('üéØ Method 1 failed, trying Method 2:', e);
             
             // Method 2: Simple plane with image
             compassImage = document.createElement('a-plane');
             compassImage.setAttribute('id', 'compass-triggered-image');
             compassImage.setAttribute('src', 'testimg.jpg');
             compassImage.setAttribute('position', '0 1.5 -2');
             compassImage.setAttribute('width', '2');
             compassImage.setAttribute('height', '2');
             compassImage.setAttribute('rotation', '0 0 0');
             
             console.log('üéØ Method 2: Plane created');
           }
           
           // Add to AR scene
           const arContent = document.getElementById('ar-content');
           arContent.appendChild(compassImage);
           
           // Add a glowing sphere to make it super visible
           const glowSphere = document.createElement('a-sphere');
           glowSphere.setAttribute('position', '0 2.5 -2');
           glowSphere.setAttribute('radius', '0.3');
           glowSphere.setAttribute('color', '#FFD700');
           glowSphere.setAttribute('material', 'shader: flat; emissive: #FFD700; emissiveIntensity: 0.8');
           glowSphere.setAttribute('animation', 'property: scale; to: 1.5 1.5 1.5; dur: 1000; loop: true; dir: alternate');
           arContent.appendChild(glowSphere);
           
           // Add text label above the image
           const labelText = document.createElement('a-text');
           labelText.setAttribute('value', 'üéØ COMPASS TRIGGERED!');
           labelText.setAttribute('position', '0 3 -2');
           labelText.setAttribute('align', 'center');
           labelText.setAttribute('width', '4');
           labelText.setAttribute('color', '#FFD700');
           labelText.setAttribute('font', 'kelsans');
           arContent.appendChild(labelText);
           
           console.log('üéØ 3D Compass image created and added to AR scene at position:', compassImage.getAttribute('position'));
           console.log('üéØ AR Content children count:', arContent.children.length);
           console.log('üéØ Added glow sphere and label for visibility');
           
           // Update status with current range
           document.getElementById('data-status').textContent = `üéØ 3D Image Active (${compassRange.min}-${compassRange.max}¬∞)`;
           document.getElementById('data-status').className = 'success';
           
           // Add some animation to make it more visible
           setTimeout(() => {
             if (compassImage) {
               try {
                 compassImage.setAttribute('animation', 'property: rotation; to: 0 360 0; dur: 5000; loop: true');
                 console.log('üéØ Animation added to image');
               } catch (e) {
                 console.log('üéØ Animation failed:', e);
               }
             }
           }, 500);
         }
       }
       
       // Hide the compass-triggered image
       function hideCompassTriggeredImage() {
         const compassImage = document.getElementById('compass-triggered-image');
         if (compassImage) {
           compassImage.remove();
           
           // Also remove any glow spheres and labels
           const arContent = document.getElementById('ar-content');
           const glowSpheres = arContent.querySelectorAll('a-sphere');
           const labels = arContent.querySelectorAll('a-text');
           
           glowSpheres.forEach(sphere => {
             if (sphere.getAttribute('color') === '#FFD700') {
               sphere.remove();
             }
           });
           
           labels.forEach(label => {
             if (label.getAttribute('value') === 'üéØ COMPASS TRIGGERED!') {
               label.remove();
             }
           });
           
           console.log('üéØ Compass image and related elements hidden');
           
           // Update status back to normal
           document.getElementById('data-status').textContent = '‚úÖ AR Content Ready!';
           document.getElementById('data-status').className = 'success';
         }
       }
       
       // Test compass trigger manually
       function testCompassTrigger() {
         const statusDiv = document.getElementById('camera-status');
         const messageDiv = document.getElementById('camera-message');
         
         statusDiv.style.display = 'block';
         
         if (sensorData.compass.active) {
           const heading = sensorData.compass.heading;
           if (heading >= compassRange.min && heading <= compassRange.max) {
             messageDiv.textContent = `üéØ Compass Triggered! (${heading.toFixed(1)}¬∞) - Image should be visible`;
             showCompassTriggeredImage();
           } else {
             messageDiv.textContent = `üß≠ Compass: ${heading.toFixed(1)}¬∞ - Not in trigger range (${compassRange.min}-${compassRange.max}¬∞)`;
           }
         } else {
           messageDiv.textContent = '‚ùå Compass not active - rotate device to activate';
         }
       }
       
       // Debug function to manually create a 3D object
       function debugCreate3DObject() {
         console.log('üîß Debug: Creating 3D object manually...');
         
         const arContent = document.getElementById('ar-content');
         console.log('üîß Debug: AR Content element:', arContent);
         console.log('üîß Debug: AR Content children before:', arContent.children.length);
         
         // Create a simple red cube for testing
         const testCube = document.createElement('a-box');
         testCube.setAttribute('position', '0 0 -3');
         testCube.setAttribute('width', '1');
         testCube.setAttribute('height', '1');
         testCube.setAttribute('depth', '1');
         testCube.setAttribute('color', '#FF0000');
         testCube.setAttribute('animation', 'property: rotation; to: 0 360 0; dur: 3000; loop: true');
         
         arContent.appendChild(testCube);
         
         console.log('üîß Debug: Test cube added, children after:', arContent.children.length);
         console.log('üîß Debug: Test cube element:', testCube);
         
         // Show status
         document.getElementById('data-status').textContent = 'üîß Debug: Red cube created at (0, 0, -3)';
         document.getElementById('data-status').className = 'success';
         
         // Remove after 5 seconds
         setTimeout(() => {
           testCube.remove();
           document.getElementById('data-status').textContent = '‚úÖ AR Content Ready!';
           console.log('üîß Debug: Test cube removed');
         }, 5000);
       }
       
       // Menu functions
       function toggleMenu() {
         const menuPanel = document.getElementById('menu-panel');
         if (menuPanel.style.display === 'none' || menuPanel.style.display === '') {
           menuPanel.style.display = 'block';
         } else {
           menuPanel.style.display = 'none';
         }
       }
       
       function hideMenu() {
         document.getElementById('menu-panel').style.display = 'none';
       }
       
       // Update compass range from inputs
       function updateCompassRange() {
         const minInput = document.getElementById('min-range');
         const maxInput = document.getElementById('max-range');
         
         const newMin = parseInt(minInput.value);
         const newMax = parseInt(maxInput.value);
         
         if (newMin >= 0 && newMax <= 359 && newMin <= newMax) {
           compassRange.min = newMin;
           compassRange.max = newMax;
           
           // Update status
           document.getElementById('data-status').textContent = `üß≠ Compass Range: ${newMin}¬∞-${newMax}¬∞`;
           
           // Check current compass position
           if (sensorData.compass.active) {
             checkCompassForSpecialContent();
           }
           
           // Hide menu after update
           hideMenu();
         } else {
           alert('Please enter valid range: 0-359, min ‚â§ max');
         }
       }

                     // Initialize the app when the page loads
       window.addEventListener('load', function() {
         console.log('AR App loaded successfully!');
         
         // iOS-specific initialization
         if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
           console.log('iOS device detected - optimizing for iOS');
         }
         
         // Initialize all sensors
         initializeSensors();
         
         // Get location first
         getLocation();
         
         // Test camera access after a short delay
         setTimeout(testCameraAccess, 1000);
         
         // Update status to show back camera is active
         document.getElementById('data-status').textContent = 'üì∑ Back Camera Active';
         document.getElementById('data-status').className = 'success';
         
         // Update sensor data display periodically
         setInterval(function() {
           Object.keys(sensorData).forEach(sensorType => {
             if (sensorData[sensorType].active) {
               updateSensorDisplay(sensorType);
             }
           });
         }, 100);
         
         // Close menu when clicking outside
         document.addEventListener('click', function(event) {
           const menuPanel = document.getElementById('menu-panel');
           const menuToggle = document.getElementById('menu-toggle');
           
           if (!menuPanel.contains(event.target) && !menuToggle.contains(event.target)) {
             menuPanel.style.display = 'none';
           }
         });
       });

      // Handle iOS-specific events
      document.addEventListener('touchstart', function(e) {
        // Prevent zoom on double tap
        if (e.touches.length > 1) {
          e.preventDefault();
        }
      }, { passive: false });

      // Handle device orientation changes
      window.addEventListener('orientationchange', function() {
        setTimeout(function() {
          // Refresh the view after orientation change
          window.scrollTo(0, 0);
        }, 100);
      });

      // Update location periodically (every 30 seconds)
      setInterval(getLocation, 30000);
    </script>
  </body>
</html>
